<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Get Things Done v1.2.4 by Grisha Tsvetkov</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f5f5;
      overflow: hidden;
      width: 100vw; height: 100vh; position: relative;
    }
    #app { width: 100%; height: 100%; position: relative; overflow: hidden; }
    #checkboxes-container { width: 100%; height: 100%; position: relative; overflow: hidden; min-height: 100vh; }

    /* Progress Bar */
    #progress-container { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); width: 300px; z-index: 1200; }
    #progress-bar { width: 100%; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden; }
    #progress-fill { height: 100%; background: #000; width: 0%; transition: width 0.3s ease; }
    #progress-text { text-align: center; margin-top: 8px; font-size: 12px; font-weight: 500; color: #666; }

    /* Checkboxes */
    .checkbox-item { position: absolute; display: flex; align-items: center; gap: 10px; cursor: pointer;
      user-select: none; transition: opacity 0.2s ease; padding: 5px 8px; border-radius: 4px; }
    .checkbox-item:hover { opacity: 0.7; background: rgba(0,0,0,0.03); }
    .checkbox-item input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; }
    .checkbox-item label { cursor: pointer; font-size: 14px; color: #333; white-space: nowrap; }

    /* Completion Screen */
    #completion-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); display: none; flex-direction: column;
      justify-content: center; align-items: center; z-index: 2400; color: white; }
    #completion-screen.active { display: flex; }
    #project-info { position: absolute; top: 30px; text-align: center; }
    #project-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; }
    #project-author { font-size: 12px; opacity: 0.7; margin-bottom: 8px; }
    #project-description { font-size: 11px; opacity: 0.5; max-width: 400px; line-height: 1.4; }
    #completion-message { font-size: 48px; font-weight: bold; margin-bottom: 20px; text-align: center; }
    #completion-submessage { font-size: 24px; margin-bottom: 40px; opacity: 0.8; }
    #name-input-container { margin-bottom: 30px; }
    #name-input { background: transparent; border: none; border-bottom: 2px solid white; color: white;
      font-size: 20px; padding: 10px; text-align: center; width: 300px; outline: none; }
    #name-input::placeholder { color: rgba(255,255,255,0.5); }
    #badge { background: white; color: black; padding: 20px 40px; border-radius: 8px; font-size: 18px; font-weight: 500; margin-bottom: 30px; }

    /* Certificate */
    #certificate { display: none; background: white; color: black; padding: 40px 60px; border-radius: 12px;
      text-align: center; max-width: 500px; border: 8px solid gold; box-shadow: 0 10px 40px rgba(0,0,0,0.3); position: relative; }
    #certificate.show { display: block; }
    #certificate-title { font-size: 32px; font-weight: bold; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 2px; }
    #certificate-body { font-size: 16px; line-height: 1.8; margin-bottom: 25px; }
    #certificate-name { font-size: 28px; font-weight: bold; margin: 25px 0; font-style: italic; border-bottom: 2px solid #333; display: block; padding-bottom: 8px; }
    #certificate-task-count { font-size: 20px; color: gold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
    #certificate-footer { margin-top: 30px; font-size: 12px; opacity: 0.6; }
    #certificate-badge { position: absolute; top: -20px; right: -20px; background: gold; border-radius: 50%; width: 80px; height: 80px;
      display: flex; align-items: center; justify-content: center; font-size: 40px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }

    #reset-hint { font-size: 14px; opacity: 0.6; margin-top: 20px; }

    /* Confetti Canvas */
    .gtd-confetti { position: fixed; inset: 0; width: 100vw; height: 100vh; pointer-events: none !important;
      z-index: 2147483647 !important; display: block; }

    /* Help Text */
    #help-text { position: fixed; bottom: 20px; right: 20px; font-size: 12px; color: #999; opacity: 0.5; transition: opacity 0.3s; z-index: 1200; }
    #help-text:hover { opacity: 1; }

    /* Debug Panel */
    #debug-panel { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.85); color: white;
      padding: 15px; border-radius: 8px; font-size: 11px; font-family: 'Courier New', monospace;
      z-index: 1300; min-width: 200px; backdrop-filter: blur(10px); cursor: move; user-select: none; display: none; }
    #debug-panel:active { cursor: grabbing; }
    #debug-panel .debug-title { font-weight: bold; font-size: 12px; margin-bottom: 8px; color: #4ecdc4; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 5px; }
    #debug-panel .debug-line { margin: 3px 0; }
    #debug-panel .debug-label { color: #95e1d3; }
    #debug-panel .debug-value { color: #ffe66d; }
    #debug-panel .debug-params { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 10px; }
    #reset-button { margin-top: 10px; padding: 8px 16px; background: #4ecdc4; color: #000; border: none; border-radius: 4px;
      font-size: 11px; font-weight: bold; cursor: pointer; width: 100%; transition: all 0.2s; font-family: 'Courier New', monospace; }
    #reset-button:hover { background: #95e1d3; transform: translateY(-1px); }
    #reset-button:active { transform: translateY(0); }
  </style>
</head>
<body>
  <div id="app">
    <div id="progress-container">
      <div id="progress-bar"><div id="progress-fill"></div></div>
      <div id="progress-text">0 / 0</div>
    </div>

    <div id="checkboxes-container"></div>

    <div id="completion-screen">
      <div id="project-info">
        <div id="project-title">Get Things Done v1.2.4</div>
        <div id="project-author">by Grisha Tsvetkov</div>
        <div id="project-description">An ironic productivity simulator celebrating the dopamine rush of checking boxes</div>
      </div>
      <div id="completion-message">Well done!</div>
      <div id="completion-submessage">You did it! üéâ</div>
      <div id="name-input-container"><input type="text" id="name-input" placeholder="Your name..." maxlength="30"></div>
      <div id="badge"></div>
      <div id="certificate">
        <div id="certificate-badge">üèÜ</div>
        <div id="certificate-title">Certificate of Productivity</div>
        <div id="certificate-body">
          This certifies that
          <div id="certificate-name"></div>
          has successfully completed <strong id="certificate-task-count"></strong> tasks<br>
          and achieved peak productivity simulation
        </div>
        <div id="certificate-date"></div>
        <div id="certificate-footer">
          Official Productivity Achievement ‚Ä¢ Get Things Done v1.2.4<br>
          <em>Warning: May cause false sense of accomplishment</em>
        </div>
      </div>
      <div id="reset-hint">Press R to start again</div>
    </div>

    <div id="help-text">Press R to reset</div>

    <div id="debug-panel">
      <div class="debug-title">DEBUG INFO</div>
      <div class="debug-line"><span class="debug-label">Seed:</span> <span class="debug-value" id="debug-seed">-</span></div>
      <div class="debug-line"><span class="debug-label">Layout:</span> <span class="debug-value" id="debug-layout">-</span></div>
      <div class="debug-line"><span class="debug-label">Count:</span> <span class="debug-value" id="debug-count">-</span></div>
      <div class="debug-params" id="debug-params"></div>
      <button id="reset-button">RESET (R)</button>
    </div>
  </div>

  <script>
    // ======================= Debug toggle =======================
    const DEBUG_ENABLED =
      /(?:^|[?&])debug=1(?:&|$)/.test(location.search) ||
      localStorage.getItem('gtd_debug') === '1';

    function applyDebugVisibility() {
      const p = document.getElementById('debug-panel');
      if (p) p.style.display = DEBUG_ENABLED ? 'block' : 'none';
    }

    // Public helpers
    window.__gtd = {
      showDebug: () => { localStorage.setItem('gtd_debug', '1'); location.reload(); },
      hideDebug: () => { localStorage.removeItem('gtd_debug'); location.reload(); },
      setSeed: s => { localStorage.setItem('gtd_seed', String(s)); location.reload(); },
      clearSeed: () => { localStorage.removeItem('gtd_seed'); location.reload(); }
    };

    // ======================= Seeded RNG =======================
    class SeededRandom {
      constructor(seed) { this.seed = seed|0; this.current = this.seed; }
      next() { this.current = (this.current * 1103515245 + 12345) & 0x7fffffff; return this.current / 0x7fffffff; }
      random() { return this.next(); }
      randomInt(min, max) { return Math.floor(this.random() * (max - min)) + min; }
      randomFloat(min, max) { return this.random() * (max - min) + min; }
      choice(array) { return array[this.randomInt(0, array.length)]; }
    }

    // ======================= Global =======================
    let rng;
    let currentSeed;
    let currentLayout;
    let currentParams = {};
    let checkboxes = [];
    let checkedCount = 0;
    let totalCount = 0;

    const TEXTS = {
     <style>
  html, body{
    height:100%;
    overflow:hidden;
    margin:0;
    padding:0;
  }
  :root{
    --gtd-fg:#111;
  }
  #gtd-app *{box-sizing:border-box}
  #gtd-app{
    position:relative;
    width:100%;
    height:100vh;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  }
  #gtd-checkboxes{
    width:100%;
    height:calc(100vh - 120px);
    position:relative;
    overflow:hidden;
  }

  /* SECTION: top bar */
  #gtd-progress{
    position:fixed;
    top:16px;
    left:50%;
    transform:translateX(-50%);
    width:min(740px, 100vw - 32px);
    z-index:1200;
    pointer-events:none;
  }
  #gtd-progress-top{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    font-size:11px;
    margin-bottom:6px;
    text-transform:uppercase;
    letter-spacing:.08em;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(4px);
    color:#fff;
    padding:4px 14px;
    border-radius:999px;
    pointer-events:auto;
  }
  #gtd-progress-bar{
    width:100%;
    height:8px;
    background:rgba(128,128,128,0.25);
    border-radius:4px;
    overflow:hidden;
  }
  #gtd-progress-fill{
    height:100%;
    background:#207dff;
    width:0%;
    transition:width .25s ease;
  }

  /* SECTION: task items */
  .gtd-item{
    position:absolute;
    display:flex;
    align-items:center;
    gap:8px;
    cursor:pointer;
    user-select:none;
    padding:4px 8px;
    border-radius:4px;
    transition:background .15s ease;
  }
  .gtd-item:hover{
    background:rgba(128,128,128,0.18);
  }
  .gtd-item input[type="checkbox"]{
    width:20px;
    height:20px;
    cursor:pointer;
    accent-color:#207dff;
  }
  .gtd-item label{
    cursor:pointer;
    font-size:14px;
    white-space:nowrap;
  }

  /* SECTION: done overlay */
  #gtd-done{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.94);
    display:none;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    z-index:2400;
    color:#fff;
    padding:16px;
  }
  #gtd-done.active{display:flex}
  #gtd-name-wrap{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
    margin-bottom:24px;
  }
  #gtd-name{
    background:transparent;
    border:none;
    border-bottom:2px solid #fff;
    color:#fff;
    font-size:16px;
    padding:8px 4px;
    text-align:center;
    width:min(76vw,340px);
    outline:none;
  }
  #gtd-submit{
    background:#fff;
    color:#000;
    padding:8px 14px;
    border-radius:7px;
    border:none;
    font-weight:600;
    cursor:pointer;
  }

  /* SECTION: certificate */
  #gtd-cert{
    display:none;
    background:#fff;
    color:#000;
    padding:56px 48px 52px 48px;
    border-radius:18px;
    text-align:center;
    max-width:min(92vw,640px);
    min-height:460px;
    border:10px solid #ffcb2f;
    box-shadow:0 14px 44px rgba(0,0,0,.35);
    position:relative;
  }
  #gtd-cert.show{display:block}
  #gtd-cert-badge{
    position:absolute;
    top:-66px;
    left:50%;
    transform:translateX(-50%);
    background:#ffcb2f;
    width:130px;
    height:130px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:58px;
    box-shadow:0 12px 30px rgba(0,0,0,.25);
  }
  #gtd-cert-title{
    margin-top:34px;
    font-size:24px;
    font-weight:800;
    margin-bottom:10px;
    text-transform:uppercase;
    letter-spacing:2.4px;
  }
  #gtd-cert-body{
    font-size:15px;
    line-height:1.7;
    margin-bottom:18px;
  }
  #gtd-cert-name{
    font-size:24px;
    font-weight:800;
    margin:10px 0 10px 0;
    border-bottom:2px solid #333;
    display:block;
    padding-bottom:8px;
  }
  #gtd-cert-count{
    font-size:18px;
    color:#ffcb2f;
    text-shadow:1px 1px 2px rgba(0,0,0,.25);
  }
  #gtd-cert-date{
    font-size:12px;
    opacity:.6;
    margin-top:16px;
  }
  #gtd-cert-footer{
    margin-top:10px;
    font-size:12px;
    opacity:.7;
  }
  #gtd-cert-project{
    margin-top:26px;
    font-size:10px;
    opacity:.55;
    line-height:1.35;
  }
  #gtd-reset-hint{
    font-size:11px;
    opacity:.6;
    margin-top:14px;
  }

  /* SECTION: confetti canvas */
  .gtd-confetti{
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    pointer-events:none!important;
    z-index:999999!important;
    background:transparent;
  }

  /* SECTION: debug panel */
  #gtd-debug{
    position:fixed;
    top:70px;
    right:70px;
    background:rgba(0,0,0,0.85);
    color:#fff;
    padding:12px 14px;
    border-radius:8px;
    font-size:11px;
    font-family:"Courier New",monospace;
    z-index:1300;
    min-width:200px;
    backdrop-filter:blur(10px);
    display:none;
    cursor:grab;
  }
  #gtd-debug .gtd-debug-title{
    font-weight:700;
    font-size:12px;
    margin-bottom:6px;
    color:#4ecdc4;
    text-align:center;
    border-bottom:1px solid rgba(255,255,255,.3);
    padding-bottom:4px;
    cursor:grab;
  }
  #gtd-debug .gtd-debug-line{margin:3px 0;display:flex;justify-content:space-between;gap:8px}
  #gtd-debug .gtd-debug-label{opacity:.6}
  #gtd-debug .gtd-debug-params{margin-top:6px;max-height:130px;overflow:auto}
</style>
</head>
<body>
<div id="gtd-app">
  <div id="gtd-progress">
    <div id="gtd-progress-top">
      <span id="gtd-version-label">get things done v1.3.11</span>
      <span id="gtd-progress-text">0 / 0</span>
      <span id="gtd-hint-label">press R to restart</span>
    </div>
    <div id="gtd-progress-bar"><div id="gtd-progress-fill"></div></div>
  </div>

  <div id="gtd-checkboxes" aria-live="polite"></div>

  <div id="gtd-done" aria-live="polite">
    <div id="gtd-name-wrap">
      <input id="gtd-name" placeholder="Your name..." maxlength="30" autocomplete="name" />
      <button id="gtd-submit" type="button">Generate certificate</button>
    </div>
    <div id="gtd-cert" role="dialog" aria-modal="true">
      <div id="gtd-cert-badge">üèÜ</div>
      <div id="gtd-cert-title">Certificate of productivity</div>
      <div id="gtd-cert-body">
        This certifies that
        <span id="gtd-cert-name"></span>
        has completed <strong id="gtd-cert-count"></strong> tasks
      </div>
      <div id="gtd-cert-date"></div>
      <div id="gtd-cert-footer">
        Official Productivity Achievement<br>
        Warning: may cause false sense of accomplishment
      </div>
      <div id="gtd-cert-project">
        Get Things Done by Grisha Tsvetkov<br>
        Ironic productivity simulator celebrating the dopamine rush of checking boxes
      </div>
      <div id="gtd-reset-hint">Press R to start again</div>
    </div>
  </div>

  <div id="gtd-debug">
    <div class="gtd-debug-title">DEBUG INFO</div>
    <div class="gtd-debug-line"><span class="gtd-debug-label">Seed:</span> <span id="gtd-debug-seed">-</span></div>
    <div class="gtd-debug-line"><span class="gtd-debug-label">Layout:</span> <span id="gtd-debug-layout">-</span></div>
    <div class="gtd-debug-line"><span class="gtd-debug-label">Count:</span> <span id="gtd-debug-count">-</span></div>
    <div class="gtd-debug-params" id="gtd-debug-params"></div>
  </div>
</div>

<script>
  /* SECTION: CONFIG
     –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –ø—Ä–∞–≤–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ;
     –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –±–æ–ª—å—à–µ –∑–∞–¥–∞—á, –ø–æ–¥–Ω–∏–º–∏ countMax;
     –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –±–æ–ª—å—à–µ –ø—Ä–æ—Å—Ç—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π, –ø–æ–¥–Ω–∏–º–∏ percSimple. */
  const GTD_SETUP = {
    version: 'v1.3.11',
    countMin: 10,
    countMax: 26,
    percSerious: 0.35,
    percAbsurd: 0.16,
    percQuotes: 0.12,
    percSimple: 0.22,
    percEmpty: 0.15
  };
  const GTD_CONFIG = { topOffset: 140, bottomOffset: 24, sideOffset: 30 };
  const GTD_MIN_RENDER_HEIGHT = 420;
  const GTD_DEBUG_ENABLED =
    /(?:^|[?&])debug=1(?:&|$)/.test(location.search) ||
    localStorage.getItem('gtd_debug') === '1';

  /* SECTION: TEXT POOLS ‚Äî 100 items per bucket, ~10 RU each */
const GTD_TEXTS = {
  serious: [
    "Update portfolio maybe",
    "Check if CV still makes sense",
    "Reply to one nice email",
    "Open project, stare at it",
    "Rename that file again",
    "Pretend to plan something",
    "Save progress for future you",
    "Revisit an old idea",
    "Upload something unfinished",
    "Call it a draft",
    "Add one new line",
    "Fix one thing you notice",
    "Tidy layers, or not",
    "Make folder chaos visible",
    "Delete duplicate screenshots",
    "Sort nothing, feel better",
    "Write title before concept",
    "Sketch, erase, sketch again",
    "Archive what still matters",
    "Push something somewhere",
    "Mark one item done twice",
    "Backup imagination",
    "Close half of tabs",
    "Sync with your mood",
    "Review one random note",
    "Change font for no reason",
    "Adjust color, trust feeling",
    "Export again just in case",
    "Leave one task unfinished",
    "Send yourself a compliment",
    "Test if it still works",
    "Check deadlines, ignore them",
    "Move file to another folder",
    "Take credit for small thing",
    "Add something to portfolio",
    "Forget why you opened this",
    "Upload, then delete, then rest",
    "Write todo: breathe",
    "Hide taskbar anxiety",
    "Turn off notifications",
    "Replace urgent with soon",
    "Write one honest line",
    "Update the title again",
    "Check design, trust instinct",
    "Fix typo, celebrate",
    "Email future collaborator",
    "Name project final_v2",
    "Add emoji to filename",
    "Change nothing, save anyway",
    "Reward yourself for existing",
    "Mark this click as work",
    "Log five minutes",
    "Pin one reference",
    "Collect one screenshot",
    "Label that folder",
    "Clean export settings",
    "Re-run last render",
    "Write a tiny brief",
    "State the goal softly",
    "Note one constraint",
    "Draft a caption",
    "Pick a cover image",
    "Tag the project",
    "Archive one chat",
    "Decline one meeting",
    "Accept one idea",
    "Rename final to final_final",
    "Refactor a sentence",
    "Nudge layout a bit",
    "Test mobile view",
    "Check alt text",
    "Trim whitespace",
    "Sort by date",
    "Star one email",
    "Unsubscribe once",
    "Mute one channel",
    "Set status: Focus",
    "Book a short slot",
    "Write standup notes",
    "Outline three bullets",
    "Clarify acceptance criteria",
    "Reduce scope kindly",
    "Park one feature",
    "Ship a micro-update",
    "Share WIP preview",
    "Ask for one review",
    "Log a tiny bug",
    "Move task to Today",
    "Move task to Later",
    "Celebrate a small win",
    "Draft next steps",
    "Re-read the brief",
    "Confirm time zone",
    "Check licenses",
    "Export a thumbnail",
    "Link to repo",
    "Sync cloud files",
    "Verify backup",
    "Calibrate display",
    "Update changelog",
    "Commit with a smile",
    "–ù–∞–ø–∏—à–∏ –æ–¥–Ω–æ –ø–∏—Å—å–º–æ",
    "–ü–µ—Ä–µ–∏–º–µ–Ω—É–π —Ñ–∞–π–ª —Å–ø–æ–∫–æ–π–Ω–æ",
    "–û–±–Ω–æ–≤–∏ –±–∏–æ —á—É—Ç—å-—á—É—Ç—å",
    "–°–æ—Ö—Ä–∞–Ω–∏ —á–µ—Ä–Ω–æ–≤–∏–∫ —Å–µ–π—á–∞—Å"
  ],

  absurd: [
    "High-five your screen",
    "Feed the algorithm",
    "Blink twice for luck",
    "Schedule a nap",
    "Click me again",
    "Delete Monday",
    "Ask AI for meaning",
    "Compliment your cursor",
    "Draw a circle mentally",
    "Pet invisible cat",
    "Like your own thought",
    "Email future you",
    "Water your Wi-Fi",
    "Count to almost ten",
    "Wave at the void",
    "Debug your feelings",
    "Rename reality v2",
    "Install patience",
    "Unplug the moon",
    "Ping the universe",
    "Charge your aura",
    "Mute the chaos",
    "Scroll with dignity",
    "Refactor destiny",
    "Optimize a yawn",
    "Minify worries",
    "Defragment dreams",
    "Clear cache of doubts",
    "Enable dark coffee",
    "Resize the horizon",
    "Reboot a cloud",
    "Balance one pixel",
    "Rotate your fate",
    "Select all joy",
    "Duplicate calm",
    "Invert boredom",
    "Center the soul",
    "Snap to grid life",
    "Outline your silence",
    "Flatten expectations",
    "Mask one thought",
    "Nudge reality 1 px",
    "Hide guidance lines",
    "Group tiny hopes",
    "Deselect anxiety",
    "Lock inner guide",
    "Rasterize chaos",
    "Uncheck gravity",
    "Pet a cloud",
    "Win an argument with yourself",
    "Install a nap",
    "Rename brain to brain_final",
    "Archive your doubts",
    "Refill imagination buffer",
    "Enable whisper mode",
    "Turn off the noise",
    "Resize the sun 80%",
    "Export one rainbow",
    "Commit to vibes",
    "Ship a feeling",
    "Open a wormhole",
    "Unzip a smile",
    "Recolor the sky",
    "Fork your mood",
    "Merge two naps",
    "Rebase reality",
    "Push to cosmos",
    "Pull from dreams",
    "Lint your thoughts",
    "Console.log happiness",
    "AI, take the wheel",
    "Summon tiny dragons",
    "Mute the apocalypse",
    "Drink a pixel",
    "Bake a timeline",
    "Cache a hug",
    "Map joy to ctrl+J",
    "Upgrade your aura",
    "Hotfix destiny",
    "Rollback stress",
    "Refactor naps",
    "Hydrate your muse",
    "Defuse overthinking",
    "Render curiosity",
    "Compile a laugh",
    "Minimap serenity",
    "Checkpoint reality",
    "Patch the void",
    "Toggle hope on",
    "Blur the worry",
    "Sharpen delight",
    "Untangle spaghetti mind",
    "Zoom heart to 120%",
    "Sketch a parallel you",
    "Teleport attention",
    "Invite chaos to dance",
    "–ü–æ–≥–ª–∞–¥—å –ø—É—Å—Ç–æ—Ç—É",
    "–ü–µ—Ä–µ–∏–º–µ–Ω—É–π —Å–∫—É–∫—É",
    "–û–±–Ω–∏–º–∏ –º–æ–Ω–∏—Ç–æ—Ä –≤–∑–≥–ª—è–¥–æ–º",
    "–ü–æ—à–ª–∏ –º–µ–º –≤—Å–µ–ª–µ–Ω–Ω–æ–π",
    "–ù–∞–∂–º–∏ —Å—é–¥–∞ –µ—â—ë —Ä–∞–∑",
    "–°–æ—Ö—Ä–∞–Ω–∏ –≤—Å–ª—É—Ö —Ç–∏—à–∏–Ω—É"
  ],

  quotes: [
    "Done is better than perfect",
    "Your pace is enough",
    "Trust the process",
    "Ship, then improve",
    "Document before doing",
    "Small steps count",
    "Perfection is delay",
    "Progress is a feeling",
    "The list never ends",
    "Rest is also work",
    "Focus is a choice",
    "Momentum beats motivation",
    "Clarity loves simple",
    "Start small, start now",
    "Silence helps thinking",
    "One thing at a time",
    "Constraints create form",
    "Drafts are allowed",
    "Routine makes freedom",
    "Attention is finite",
    "Time is material",
    "Cut to the essential",
    "Stop. Look. Continue.",
    "WIP is a place",
    "Iterations tell truth",
    "Friction reveals shape",
    "Deadlines are mirrors",
    "Care is a method",
    "Simplicity scales",
    "You are not late",
    "Move at human speed",
    "Name it to see it",
    "Notes remember you",
    "Energy is a resource",
    "Drafts invite progress",
    "Pause creates edges",
    "Reduce to decide",
    "Patience is practice",
    "Frames define meaning",
    "Order follows action",
    "Tiny wins matter",
    "Less noise, more signal",
    "Keep it humane",
    "You can stop now",
    "Art is a checkbox",
    "Finish is a phase",
    "Good enough is good",
    "Done is a mood",
    "Click = intention",
    "Continue tomorrow",
    "Good enough for now",
    "You clicked, that counts",
    "No rush today",
    "Almost done, maybe",
    "You are doing fine",
    "Progress is a vibe",
    "Perfection is a trap",
    "Done-ish is done",
    "Halfway is still movement",
    "Rest is progress too",
    "Tiny things add up",
    "Be proud of minimal effort",
    "Patience is an action",
    "Simplicity wins again",
    "Click = courage",
    "Creative chaos allowed",
    "Today is enough",
    "Start small, stay kind",
    "You did something",
    "Art is never finished",
    "One click, one mark",
    "The list loves you",
    "Momentum is gentle",
    "It is fine as it is",
    "Drafts are real too",
    "Mess counts as process",
    "Good job, unknown human",
    "Meaning optional",
    "Calm is productive",
    "Nothing to prove",
    "Unfinished is a style",
    "Pause creates shape",
    "Done. Kind of.",
    "Perfectly imperfect",
    "Clicking is self-care",
    "This moment is valid",
    "A small win counts",
    "Less pressure, more presence",
    "It is okay to not finish",
    "Gentle effort only",
    "No one is watching",
    "This is also art",
    "Breathing counts",
    "Effort = enough",
    "Today‚Äôs task: being",
    "Succeed in resting",
    "Stay a little soft",
    "One more click of kindness",
    "All checked, all good",
    "–°–¥–µ–ª–∞–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ",
    "–ú–∞–ª—ã–µ —à–∞–≥–∏ –≤–∞–∂–Ω—ã",
    "–î—ã—à–∏ –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–π",
    "–°–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ",
    "–ü–∞—É–∑–∞ —Ç–æ–∂–µ —Ä–∞–±–æ—Ç–∞",
    "–°–µ–≥–æ–¥–Ω—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ"
  ],

  simple: [
    "Inhale",
    "Exhale",
    "Hold",
    "Look left",
    "Look right",
    "Blink slowly",
    "Drink water",
    "Stand up",
    "Stretch fingers",
    "Relax shoulders",
    "Check posture",
    "Close one tab",
    "Open window",
    "Sit comfortably",
    "Touch keyboard",
    "Breathe again",
    "Slow down",
    "Smile once",
    "Wash your face",
    "Walk a minute",
    "Send one photo",
    "Post one story",
    "Save one draft",
    "Take a snapshot",
    "File a picture",
    "Share with a friend",
    "Reply with one line",
    "Write a caption",
    "Make a tiny sketch",
    "Pin one idea",
    "Set a 5-min timer",
    "Mute notifications",
    "Turn volume down",
    "Light on, light off",
    "Stand, then sit",
    "Count to five",
    "Open portfolio",
    "Pick one work",
    "Update the title",
    "Review your CV",
    "Add one link",
    "Trim one clip",
    "Color one frame",
    "Nudge 1 px",
    "Reset zoom",
    "Check battery",
    "Clean one spot",
    "Send a meme",
    "Wave hello",
    "Close an app",
    "Tidy one icon",
    "Wipe the screen",
    "Stretch wrists",
    "Roll shoulders",
    "Deep breath",
    "Short breath",
    "Look outside",
    "Look inside",
    "Pet your mind",
    "Write two words",
    "Save and exit",
    "Open and save",
    "Check time",
    "Turn on focus",
    "Turn off noise",
    "Open notes",
    "Pin a thought",
    "Archive one chat",
    "Heart one photo",
    "Post one reel",
    "Like your draft",
    "Send thanks",
    "Say hi",
    "Ask later",
    "Copy link",
    "Paste link",
    "Undo once",
    "Redo once",
    "Zoom in",
    "Zoom out",
    "Switch window",
    "Close window",
    "Open finder",
    "Empty bin",
    "Align center",
    "Align left",
    "Turn light",
    "Turn dark",
    "Play music",
    "Pause music",
    "Stand tall",
    "Sit soft",
    "Shake hands",
    "Shake head",
    "–°–ø–∞—Å–∏–±–æ",
    "–ü—Ä–æ—Å—Ç–æ –∫–ª–∏–∫–Ω–∏",
    "–ì–æ—Ç–æ–≤–æ",
    "–ù–∞–ª–µ–π –≤–æ–¥—ã",
    "–°–¥–µ–ª–∞–π –≤–¥–æ—Ö",
    "–ü–æ—Å–º–æ—Ç—Ä–∏ –≤ –æ–∫–Ω–æ",
    "–û—Ç–ø—Ä–∞–≤—å —ç–º–æ–¥–∑–∏",
    "–í—ã–∫–ª—é—á–∏ –∑–≤—É–∫"
  ]
  
  };

  /* SECTION: RANDOM CORE */
  class GTDSeededRandom {
    constructor(seed){ this.seed = seed|0; this.current = this.seed; }
    next(){ this.current = (this.current*1103515245 + 12345) & 0x7fffffff; return this.current / 0x7fffffff; }
    randomInt(min,max){ return Math.floor(this.next()*(max-min)) + min; }
    choice(arr){ return arr[this.randomInt(0, arr.length)]; }
  }

  let gtdRng, gtdSeed, gtdLayout, gtdParams = {};
  let gtdCheckboxes = [], gtdChecked = 0, gtdTotal = 0;

  /* SECTION: CONFETTI VARS */
  let gtdConfettiCanvas = null, gtdConfettiCtx = null, gtdConfettiParticles = [], gtdConfettiActive = false, gtdConfettiRAF = null;
  const GTD_CONFETTI_COLORS = ['#ff6b6b','#feca57','#48dbfb','#1dd1a1','#5f27cd','#ff9ff3'];

  /* SECTION: helper to read seed from url */
  function gtdReadSeed(){
    try{
      const u = new URL(location.href);
      return u.searchParams.get('seed') || localStorage.getItem('gtd_seed') || null;
    }catch(e){ return null; }
  }

  /* SECTION: init */
  window.addEventListener('load', function(){
    setTimeout(()=>{
      gtdInit();
      gtdEnableDebugDrag();
    }, 120);
  });

  function gtdInit(){
    const s = gtdReadSeed() || Math.floor(Math.random()*1e9);
    gtdSeed = parseInt(s,10);
    gtdRng = new GTDSeededRandom(gtdSeed);
    document.getElementById('gtd-version-label').textContent = 'get things done ' + GTD_SETUP.version;
    gtdClear();
    gtdGenerate();
    gtdUpdateProgress();
    gtdHideDone();
    gtdApplyDebugVisibility();
    gtdUpdateDebugPanel();
    gtdBindKeys();
    gtdStopConfetti();
  }

  function gtdApplyDebugVisibility(){
    document.getElementById('gtd-debug').style.display = GTD_DEBUG_ENABLED ? 'block' : 'none';
  }

  function gtdClear(){
    const cont = document.getElementById('gtd-checkboxes');
    cont.innerHTML = '';
    gtdCheckboxes = [];
    gtdChecked = 0;
    gtdTotal = 0;
  }

  /* SECTION: measure text */
  const gtdMeasureCtx = (() => { const c=document.createElement('canvas'); return c.getContext('2d'); })();
  function gtdMeasureTextWidth(text){
    gtdMeasureCtx.font = '14px -apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif';
    return 24 + (text ? gtdMeasureCtx.measureText(text).width : 0);
  }

  /* SECTION: main generate */
  function gtdGenerate(){
    const cont = document.getElementById('gtd-checkboxes');
    const rect = cont.getBoundingClientRect();
    let width = rect.width || 820;
    let height = rect.height < GTD_MIN_RENDER_HEIGHT ? GTD_MIN_RENDER_HEIGHT : rect.height;
    const M = { left:GTD_CONFIG.sideOffset, right:GTD_CONFIG.sideOffset, top:GTD_CONFIG.topOffset, bottom:GTD_CONFIG.bottomOffset, checkboxH:30 };

    const span = (GTD_SETUP.countMax - GTD_SETUP.countMin) + 1;
    let count = GTD_SETUP.countMin + (new GTDSeededRandom(gtdSeed+777).randomInt(0, span) || 0);

    const pool = [];
    const seriousN = Math.round(count * GTD_SETUP.percSerious);
    const absurdN = Math.round(count * GTD_SETUP.percAbsurd);
    const quotesN = Math.round(count * GTD_SETUP.percQuotes);
    const simpleN = Math.round(count * GTD_SETUP.percSimple);
    const emptyN = Math.max(0, count - seriousN - absurdN - quotesN - simpleN);

    for (let i=0;i<seriousN;i++) pool.push(gtdRng.choice(GTD_TEXTS.serious));
    for (let i=0;i<absurdN;i++) pool.push(gtdRng.choice(GTD_TEXTS.absurd));
    for (let i=0;i<quotesN;i++) pool.push(gtdRng.choice(GTD_TEXTS.quotes));
    for (let i=0;i<simpleN;i++) pool.push(gtdRng.choice(GTD_TEXTS.simple));
    for (let i=0;i<emptyN;i++) pool.push(null);

    for (let i=pool.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }

    /* SECTION: layout choice
       —Å—é–¥–∞ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–≤–æ–∏ —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –∏ –¥–æ–±–∞–≤–∏—Ç—å –≤ –º–∞—Å—Å–∏–≤ */
    const layouts = ['list-124','scatter','circle','letter'];
    gtdLayout = layouts[Math.abs(gtdSeed) % layouts.length];
    gtdParams = {};

    let positions;
    switch (gtdLayout) {
      case 'list-124':
        positions = gtdList124(count,width,height,pool,M);
        break;
      case 'scatter':
        positions = gtdScatter(count,width,height,pool,M);
        break;
      case 'circle':
        positions = gtdCircle(count,width,height,pool,M);
        break;
      case 'letter':
        positions = gtdLetter(count,width,height,pool,M);
        break;
      default:
        positions = gtdScatter(count,width,height,pool,M);
        break;
    }

    if (!positions || positions.length < 6){
      positions = gtdScatter(pool.length,width,height,pool,M);
    }

    if (gtdLayout !== 'list-124'){
      positions = gtdResolveOverlaps(positions,width,height,M,{iterations:70,padding:8});
    }

    positions.forEach((pos,i)=>{
      const x = Math.max(M.left, Math.min(pos.x, width - M.right - pos.width));
      const y = Math.max(M.top, Math.min(pos.y, height - M.bottom - pos.height));
      const el = gtdCreateItem(i, x, y, pool[i], pos.isNested);
      cont.appendChild(el);
      gtdCheckboxes.push(el);
    });

    gtdTotal = gtdCheckboxes.length;
  }

  /* SECTION: layout list-124
     —ç—Ç–æ —Ç–≤–æ—è –≤–µ—Ä—Å–∏—è —Å –æ—Å—Ç—Ä–æ–≤–∫–∞–º–∏ –∏ –Ω–µ–±–æ–ª—å—à–∏–º —à—É–º–æ–º. */
  function gtdList124(count,width,height,texts,M){
    const sublistCount = 5;
    const baseLine = 34;
    const indentSize = 26;
    const blockMaxW = 360;
    const nestingProbability = 0.22;

    const itemsPerSublist = [];
    let remaining = count;
    for (let i=0;i<sublistCount;i++){
      if (i === sublistCount - 1){
        itemsPerSublist.push(remaining);
      } else {
        const approx = Math.max(2, Math.floor(remaining / (sublistCount - i)));
        const jitter = Math.floor(Math.random()*2);
        const size = Math.min(approx + jitter, remaining);
        itemsPerSublist.push(size);
        remaining -= size;
      }
    }

    const blocks = [];
    const maxAttempts = 45;
    for (let i=0;i<sublistCount;i++){
      const blockH = itemsPerSublist[i] * baseLine + 20;
      let placed = false;
      let x=0, y=0, attempts=0;
      while (!placed && attempts < maxAttempts){
        x = M.left + Math.random() * (width - M.right - blockMaxW - M.left);
        y = M.top + Math.random() * (height - M.bottom - blockH - M.top);
        placed = true;
        for (const b of blocks){
          const pad = 26;
          if (!(x + blockMaxW + pad < b.x || b.x + b.width + pad < x || y + blockH + pad < b.y || b.y + b.height + pad < y)){
            placed = false;
            break;
          }
        }
        attempts++;
      }
      blocks.push({ x, y, width:blockMaxW, height:blockH });
    }

    const res = [];
    let textIdx = 0;

    for (let b=0;b<blocks.length;b++){
      const block = blocks[b];
      let y = block.y;
      const itemsHere = itemsPerSublist[b];

      for (let i=0;i<itemsHere;i++){
        if (textIdx >= count) break;
        const wantNested = i>0 && Math.random() < nestingProbability;
        const indent = wantNested ? indentSize : 0;

        const text = texts[textIdx];
        const textW = Math.min(gtdMeasureTextWidth(text), block.width - 16 - indent);

        const freeWidth = block.width - textW - indent - 16;
        const jitterX = freeWidth > 0 ? Math.random() * freeWidth : 0;

        res.push({
          x: block.x + indent + 8 + jitterX,
          y: y,
          width: textW,
          height: M.checkboxH,
          isNested: wantNested
        });

        const lineJitter = (Math.random()*6) - 3;
        y += baseLine + lineJitter;

        textIdx++;
      }
    }

    gtdParams = {
      style:'list-scattered-124',
      blocks:sublistCount,
      baseLine,
      indentSize
    };
    return res;
  }

  /* SECTION: scatter layout */
  function gtdScatter(count,width,height,texts,M){
    const res = [];
    const minX = M.left, maxX = width - M.right;
    const minY = M.top, maxY = height - M.bottom;
    const clusterCount = Math.max(2, Math.floor(count/5));
    const clusters = [];
    for (let i=0;i<clusterCount;i++){
      clusters.push({ x:minX + Math.random()*(maxX-minX), y:minY + Math.random()*(maxY-minY) });
    }
    for (let i=0;i<count;i++){
      const w = gtdMeasureTextWidth(texts[i]);
      const useCluster = Math.random()<0.4;
      if (useCluster){
        const c = clusters[Math.floor(Math.random()*clusters.length)];
        const ang = Math.random()*Math.PI*2;
        const dist = Math.random()*70;
        res.push({ x:c.x + Math.cos(ang)*dist, y:c.y + Math.sin(ang)*dist, width:w, height:M.checkboxH, isNested:Math.random()<0.12 });
      } else {
        res.push({ x:minX + Math.random()*(maxX-minX-w), y:minY + Math.random()*(maxY-minY-M.checkboxH), width:w, height:M.checkboxH, isNested:false });
      }
    }
    gtdParams = { layout:'scatter', clusters:clusterCount };
    return res;
  }

  /* SECTION: circle layout */
  function gtdCircle(count,width,height,texts,M){
    const cx = width/2;
    const cy = (height - M.bottom + M.top)/2;
    const radius = Math.min(width, height)*0.3;
    const res = [];
    for (let i=0;i<count;i++){
      const t = (i/count)*Math.PI*2;
      const w = gtdMeasureTextWidth(texts[i]);
      res.push({ x: cx + Math.cos(t)*radius - w/2, y: cy + Math.sin(t)*radius - M.checkboxH/2, width:w, height:M.checkboxH, isNested:false });
    }
    gtdParams = { layout:'circle', radius:Math.round(radius) };
    return res;
  }

  /* SECTION: letter layout
     –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤–µ—Å—å –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –∞–ª—Ñ–∞–≤–∏—Ç –∏ —Ü–∏—Ñ—Ä—ã, –Ω–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–æ—Ä–º—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö */
  function gtdLetter(count,width,height,texts,M){
    const ABC = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    const ch = ABC[Math.abs(gtdSeed) % ABC.length];
    const cx = width/2;
    const cy = (height - M.bottom + M.top)/2;
    const res = [];

    if (ch === 'G' || ch === 'O' || ch === '0' || ch === 'D'){
      const r = Math.min(width,height)*0.32;
      for (let i=0;i<count;i++){
        let t = (i/count)*Math.PI*2;
        if (ch === 'G' && t > Math.PI*0.35 && t < Math.PI*0.55) t = Math.PI*0.55;
        const w = gtdMeasureTextWidth(texts[i]);
        res.push({ x: cx + Math.cos(t)*r - w/2, y: cy + Math.sin(t)*r - M.checkboxH/2, width:w, height:M.checkboxH, isNested:false });
      }
      gtdParams = { layout:'letter', char:ch, radius:Math.round(Math.min(width,height)*0.32) };
      return res;
    }

    if (ch === 'T'){
      const topY = cy - 130;
      const wFull = 280;
      const perRow = Math.min(count, 8);
      for (let i=0;i<perRow;i++){
        const w = gtdMeasureTextWidth(texts[i]);
        const x = cx - wFull/2 + (i/(perRow-1 || 1))*wFull - w/2;
        res.push({ x, y:topY, width:w, height:M.checkboxH, isNested:false });
      }
      let y = topY + 38;
      for (let i=perRow;i<count;i++){
        const w = gtdMeasureTextWidth(texts[i]);
        res.push({ x: cx - w/2, y, width:w, height:M.checkboxH, isNested:false });
        y += 30;
      }
      gtdParams = { layout:'letter', char:ch };
      return res;
    }

    if (ch === 'L' || ch === '1'){
      const xLeft = cx - 120;
      let y = cy - 140;
      for (let i=0;i<count;i++){
        const w = gtdMeasureTextWidth(texts[i]);
        if (i < Math.floor(count*0.7)){
          res.push({ x:xLeft, y, width:w, height:M.checkboxH, isNested:false });
        } else {
          res.push({ x:xLeft + (i - Math.floor(count*0.7))*26, y:cy+90, width:w, height:M.checkboxH, isNested:false });
        }
        y += 28;
      }
      gtdParams = { layout:'letter', char:ch };
      return res;
    }

    // –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –±—É–∫–≤—ã –∫–∞–∫ –æ–≤–∞–ª
    const radX = Math.min(width,height)*0.32;
    const radY = Math.min(width,height)*0.20;
    for (let i=0;i<count;i++){
      const t = (i/count)*Math.PI*2;
      const w = gtdMeasureTextWidth(texts[i]);
      res.push({
        x: cx + Math.cos(t)*radX - w/2,
        y: cy + Math.sin(t)*radY - M.checkboxH/2,
        width:w,
        height:M.checkboxH,
        isNested:false
      });
    }
    gtdParams = { layout:'letter', char:ch, ellipse:true };
    return res;
  }

  /* SECTION: overlap resolve */
  function gtdResolveOverlaps(rects,width,height,M,opts){
    const iterations = opts.iterations || 50;
    const padding = opts.padding || 6;
    for (let iter=0; iter<iterations; iter++){
      let moved = false;
      for (let i=0;i<rects.length;i++){
        for (let j=i+1;j<rects.length;j++){
          const a = rects[i], b = rects[j];
          const ax = a.x + a.width/2, ay = a.y + a.height/2;
          const bx = b.x + b.width/2, by = b.y + b.height/2;
          const dx = ax - bx, dy = ay - by;
          const overlapX = (a.width/2 + b.width/2 + padding) - Math.abs(dx);
          const overlapY = (a.height/2 + b.height/2 + padding) - Math.abs(dy);
          if (overlapX > 0 && overlapY > 0){
            moved = true;
            const pushX = 0.6*overlapX * Math.sign(dx || (Math.random()-0.5));
            const pushY = 0.6*overlapY * Math.sign(dy || (Math.random()-0.5));
            a.x += pushX*0.5;
            b.x -= pushX*0.5;
            a.y += pushY*0.5;
            b.y -= pushY*0.5;
            a.x = Math.max(M.left, Math.min(a.x, width - M.right - a.width));
            b.x = Math.max(M.left, Math.min(b.x, width - M.right - b.width));
            a.y = Math.max(M.top, Math.min(a.y, height - M.bottom - a.height));
            b.y = Math.max(M.top, Math.min(b.y, height - M.bottom - b.height));
          }
        }
      }
      if (!moved) break;
    }
    return rects;
  }

  /* SECTION: create item */
  function gtdCreateItem(id,x,y,text,isNested){
    const div = document.createElement('div');
    div.className = 'gtd-item';
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    if (isNested){
      const s = document.createElement('span');
      s.textContent = '‚ñ∏';
      s.style.opacity = '.5';
      s.style.fontSize = '10px';
      div.appendChild(s);
    }
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.id = 'gtd-cb-'+id;
    cb.addEventListener('change', gtdOnChange);
    div.appendChild(cb);
    if (text){
      const lab = document.createElement('label');
      lab.htmlFor = cb.id;
      lab.textContent = text;
      div.appendChild(lab);
    }
    return div;
  }

  /* SECTION: checkbox change */
  function gtdOnChange(){
    gtdChecked = gtdCheckboxes.reduce((acc, el) => {
      const input = el.querySelector('input[type="checkbox"]');
      return acc + (input && input.checked ? 1 : 0);
    }, 0);
    gtdUpdateProgress();
    if (gtdTotal > 0 && gtdChecked >= gtdTotal) gtdShowDone();
  }

  /* SECTION: progress update */
  function gtdUpdateProgress(){
    document.getElementById('gtd-progress-fill').style.width = (gtdTotal ? (gtdChecked/gtdTotal)*100 : 0) + '%';
    document.getElementById('gtd-progress-text').textContent = gtdChecked + ' / ' + gtdTotal;
  }

  /* SECTION: show done */
  function gtdShowDone(){
    document.getElementById('gtd-cert-date').textContent = new Date().toLocaleDateString('en-US',{year:'numeric',month:'long',day:'numeric'});
    document.getElementById('gtd-done').classList.add('active');
    document.getElementById('gtd-name-wrap').style.display = 'flex';
    document.getElementById('gtd-cert').classList.remove('show');
    gtdStartConfetti();

    const input = document.getElementById('gtd-name');
    const btn = document.getElementById('gtd-submit');
    const submit = ()=>{
      const name = input.value.trim();
      if (name) gtdShowCert(name);
    };
    setTimeout(()=>{ input.focus({preventScroll:true}); }, 200);
    input.onkeydown = e => {
      if (e.key === 'Enter') { e.preventDefault(); submit(); }
      if (e.key === 'r' || e.key === 'R') e.stopPropagation();
    };
    btn.onclick = submit;
  }

  /* SECTION: show certificate */
  function gtdShowCert(name){
    document.getElementById('gtd-name-wrap').style.display = 'none';
    document.getElementById('gtd-cert-name').textContent = name + '!';
    document.getElementById('gtd-cert-count').textContent = gtdTotal;
    document.getElementById('gtd-cert').classList.add('show');
  }

  /* SECTION: hide done */
  function gtdHideDone(){
    document.getElementById('gtd-done').classList.remove('active');
    const input = document.getElementById('gtd-name');
    if (input) input.value = '';
    document.getElementById('gtd-cert').classList.remove('show');
  }

  /* SECTION: keybind */
  function gtdBindKeys(){
    document.removeEventListener('keydown', gtdKeyHandler);
    document.addEventListener('keydown', gtdKeyHandler);
  }
  function gtdKeyHandler(e){
    const t = e.target;
    if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;
    if (e.key === 'r' || e.key === 'R') gtdInit();
  }

  /* SECTION: confetti */
  function gtdEnsureConfetti(){
    if (gtdConfettiCanvas && gtdConfettiCtx) return;
    gtdConfettiCanvas = document.createElement('canvas');
    gtdConfettiCanvas.className = 'gtd-confetti';
    document.body.appendChild(gtdConfettiCanvas);
    gtdConfettiCtx = gtdConfettiCanvas.getContext('2d');
    gtdConfettiCtx.globalCompositeOperation = 'source-over';
    gtdSizeConfetti();
    window.addEventListener('resize', gtdSizeConfetti);
  }
  function gtdSizeConfetti(){
    if (!gtdConfettiCanvas) return;
    gtdConfettiCanvas.width = window.innerWidth;
    gtdConfettiCanvas.height = window.innerHeight;
  }
  class GTDConfettiParticle{
    constructor(){ this.reset(); }
    reset(){
      this.x = Math.random()*gtdConfettiCanvas.width;
      this.y = -20 + Math.random()*-200;
      this.vx = (Math.random()-0.5)*2.2;
      this.vy = Math.random()*1.4 + 1.1;
      this.size = Math.random()*7 + 3.5;
      this.color = GTD_CONFETTI_COLORS[Math.floor(Math.random()*GTD_CONFETTI_COLORS.length)];
      this.rotation = Math.random()*360;
      this.rotationSpeed = (Math.random()-0.5)*6;
      this.gravity = 0.04;
    }
    update(){
      this.x += this.vx;
      this.y += this.vy;
      this.vy += this.gravity;
      this.rotation += this.rotationSpeed;
      if (this.y > gtdConfettiCanvas.height + 30) this.reset();
    }
    draw(){
      gtdConfettiCtx.save();
      gtdConfettiCtx.translate(this.x, this.y);
      gtdConfettiCtx.rotate(this.rotation * Math.PI/180);
      gtdConfettiCtx.fillStyle = this.color;
      gtdConfettiCtx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
      gtdConfettiCtx.restore();
    }
  }
  function gtdStartConfetti(){
    gtdEnsureConfetti();
    gtdConfettiActive = true;
    if (!gtdConfettiParticles.length){
      for (let i=0;i<90;i++) gtdConfettiParticles.push(new GTDConfettiParticle());
    }
    gtdAnimateConfetti();
  }
  function gtdStopConfetti(){
    gtdConfettiActive = false;
    gtdConfettiParticles = [];
    if (gtdConfettiRAF) cancelAnimationFrame(gtdConfettiRAF);
    if (gtdConfettiCtx && gtdConfettiCanvas) {
      gtdConfettiCtx.clearRect(0,0,gtdConfettiCanvas.width,gtdConfettiCanvas.height);
    }
  }
  function gtdAnimateConfetti(){
    if (!gtdConfettiActive || !gtdConfettiCtx) return;
    gtdConfettiCtx.clearRect(0,0,gtdConfettiCanvas.width,gtdConfettiCanvas.height);
    if (Math.random()<0.25 && gtdConfettiParticles.length<160) gtdConfettiParticles.push(new GTDConfettiParticle());
    gtdConfettiParticles.forEach(p=>{ p.update(); p.draw(); });
    gtdConfettiRAF = requestAnimationFrame(gtdAnimateConfetti);
  }

  /* SECTION: debug panel update */
  function gtdUpdateDebugPanel(){
    if (!GTD_DEBUG_ENABLED) return;
    document.getElementById('gtd-debug-seed').textContent = gtdSeed;
    document.getElementById('gtd-debug-layout').textContent = gtdLayout;
    document.getElementById('gtd-debug-count').textContent = gtdTotal;
    const paramsEl = document.getElementById('gtd-debug-params');
    let html = '';
    for (let k in gtdParams){
      html += `<div class="gtd-debug-line"><span class="gtd-debug-label">${k}:</span><span>${gtdParams[k]}</span></div>`;
    }
    paramsEl.innerHTML = html || '<div class="gtd-debug-line"><span class="gtd-debug-label">no params</span></div>';
  }

  /* SECTION: debug drag */
  function gtdEnableDebugDrag(){
    const panel = document.getElementById('gtd-debug');
    if (!panel) return;
    let isDown = false;
    let offsetX = 0, offsetY = 0;
    panel.addEventListener('mousedown', e => {
      isDown = true;
      panel.style.cursor = 'grabbing';
      offsetX = e.clientX - panel.getBoundingClientRect().left;
      offsetY = e.clientY - panel.getBoundingClientRect().top;
    });
    document.addEventListener('mousemove', e => {
      if (!isDown) return;
      panel.style.top = (e.clientY - offsetY) + 'px';
      panel.style.left = (e.clientX - offsetX) + 'px';
      panel.style.right = 'auto';
    });
    document.addEventListener('mouseup', () => {
      isDown = false;
      panel.style.cursor = 'grab';
    });
  }
</script>

    // ======================= Debug panel fill =======================
    function updateDebugPanel() {
      document.getElementById('debug-seed').textContent = currentSeed;
      document.getElementById('debug-layout').textContent = currentLayout;
      document.getElementById('debug-count').textContent = totalCount;
      const paramsEl = document.getElementById('debug-params');
      let html = '';
      for (let k in currentParams) {
        const v = currentParams[k];
        html += `<div class="debug-line"><span class="debug-label">${k}:</span> ${typeof v === 'number' ? Number(v).toFixed(2) : v}</div>`;
      }
      paramsEl.innerHTML = html;
    }

    // ======================= Boot safe for Super =======================
    function readSeed() {
      const url = new URL(location.href);
      const qSeed = url.searchParams.get('seed');
      const hSeed = new URLSearchParams(url.hash.slice(1)).get('seed');
      const lsSeed = localStorage.getItem('gtd_seed');
      return qSeed || hSeed || lsSeed || null;
    }

    function init() {
      const s = readSeed();
      currentSeed = s ? parseInt(s, 10) : Math.floor(Math.random() * 1e9);
      rng = new SeededRandom(currentSeed);

      clearCheckboxes();
      generateCheckboxes();
      updateProgress();
      updateDebugPanel();
      hideCompletionScreen();
      stopConfetti();
      applyDebugVisibility();
    }

    function safeInit() {
      const start = () => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            const doInit = () => {
              const container = document.getElementById('checkboxes-container');
              const rect = container.getBoundingClientRect();
              if (rect.width < 50 || rect.height < 50) { setTimeout(doInit, 50); return; }
              init();
              setTimeout(() => { reset(); }, 300);
            };
            if (document.fonts && document.fonts.ready) document.fonts.ready.then(doInit);
            else doInit();
          });
        });
      };
      if (document.readyState === 'complete' || document.readyState === 'interactive') start();
      else document.addEventListener('DOMContentLoaded', start);
    }

    // ======================= Text measure =======================
    const __measureCtx = (() => { const c = document.createElement('canvas'); return c.getContext('2d'); })();
    function measureTextWidth(text) {
      if (!text) return 20;
      __measureCtx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      const w = __measureCtx.measureText(text).width;
      return 20 + 10 + w + 20;
    }

    // ======================= Layout selector from SEED =======================
    function layoutFromSeed(seed) {
      const layouts = ['scatter','list','circle','spiral','grid-noise','letter','phyllotaxis','lissajous'];
      return layouts[seed % layouts.length];
    }

    function generatePositions(count, width, height, texts) {
      currentLayout = layoutFromSeed(currentSeed);
      currentParams = {};
      switch(currentLayout) {
        case 'scatter': return generateScatterPositions(count, width, height, texts);
        case 'list': return generateListPositions(count, width, height, texts);
        case 'circle': return generateCirclePositions(count, width, height, texts);
        case 'spiral': return generateSpiralPositions(count, width, height, texts);
        case 'grid-noise': return generateGridNoisePositions(count, width, height, texts);
        case 'letter': return generateLetterPositions(count, width, height, texts);
        case 'phyllotaxis': return generatePhyllotaxisPositions(count, width, height, texts);
        case 'lissajous': return generateLissajousPositions(count, width, height, texts);
        default: return generateScatterPositions(count, width, height, texts);
      }
    }

    // Shared margins
    const MARGINS = { left: 30, right: 30, top: 140, bottom: 24, checkboxH: 30 };

    // ======================= Generators =======================
    function generateCheckboxes() {
      const container = document.getElementById('checkboxes-container');
      const rect = container.getBoundingClientRect();
      let width = rect.width, height = rect.height;
      if (width < 50 || height < 50) { setTimeout(generateCheckboxes, 50); return; }

      const availableArea = (width - MARGINS.left - MARGINS.right) * (height - MARGINS.top - MARGINS.bottom);
      const avgCheckboxSize = 180 * 50;
      let count = Math.floor(availableArea / avgCheckboxSize);
      if (width < 800) count = Math.floor(count * 0.6);
      const variation = 0.7 + rng.random() * 0.6;
      count = Math.floor(count * variation);
      totalCount = Math.max(8, Math.min(count, 28));
      checkedCount = 0;

      const textPool = [];
      const seriesCount = Math.floor(totalCount * 0.3);
      const absurdCount = Math.floor(totalCount * 0.3);
      const quotesCount = Math.floor(totalCount * 0.2);
      const emptyCount = totalCount - seriesCount - absurdCount - quotesCount;
      for (let i = 0; i < seriesCount; i++) textPool.push(rng.choice(TEXTS.serious));
      for (let i = 0; i < absurdCount; i++) textPool.push(rng.choice(TEXTS.absurd));
      for (let i = 0; i < quotesCount; i++) textPool.push(rng.choice(TEXTS.quotes));
      for (let i = 0; i < emptyCount; i++) textPool.push(null);
      shuffleArraySeeded(textPool, rng);

      let positions = generatePositions(totalCount, width, height, textPool);
      if (currentLayout !== 'list') positions = resolveOverlaps(positions, width, height, { iterations: 80, padding: 8 });

      positions.forEach((pos, i) => {
        const x = Math.max(MARGINS.left, Math.min(pos.x, width - MARGINS.right - pos.width));
        const y = Math.max(MARGINS.top, Math.min(pos.y, height - MARGINS.bottom - pos.height));
        const el = createCheckbox(i, x, y, textPool[i], pos.isNested);
        container.appendChild(el);
        checkboxes.push(el);
      });
      updateProgress();
    }

    function createCheckbox(id, x, y, text, isNested) {
      const div = document.createElement('div');
      div.className = 'checkbox-item';
      div.style.left = `${x}px`; div.style.top = `${y}px`;
      if (isNested) {
        const nestedIcon = document.createElement('span');
        nestedIcon.textContent = '‚ñ∏ '; nestedIcon.style.marginRight = '5px';
        nestedIcon.style.opacity = '0.5'; nestedIcon.style.fontSize = '10px'; div.appendChild(nestedIcon);
      }
      const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = `cb-${id}`;
      checkbox.addEventListener('change', onCheckboxChange); div.appendChild(checkbox);
      if (text) { const label = document.createElement('label'); label.htmlFor = `cb-${id}`; label.textContent = text; div.appendChild(label); }
      return div;
    }

    // Noise and overlap
    function lerp(a,b,t){ return a + t*(b-a); }
    function smoothstep(t){ return t*t*(3-2*t); }
    function hash2D(ix, iy, seed) {
      let n = Math.imul(ix, 374761393) ^ Math.imul(iy, 668265263) ^ (seed|0);
      n = (n ^ (n >>> 13)) >>> 0; n = Math.imul(n, 1274126177) >>> 0;
      return n / 4294967296;
    }
    function noise2D(x, y, scale) {
      const sx = x * scale, sy = y * scale;
      const x0 = Math.floor(sx), y0 = Math.floor(sy);
      const x1 = x0 + 1, y1 = y0 + 1;
      const fx = sx - x0, fy = sy - y0;
      const u = smoothstep(fx), v = smoothstep(fy);
      const v00 = hash2D(x0, y0, currentSeed);
      const v10 = hash2D(x1, y0, currentSeed);
      const v01 = hash2D(x0, y1, currentSeed);
      const v11 = hash2D(x1, y1, currentSeed);
      const nx0 = lerp(v00, v10, u);
      const nx1 = lerp(v01, v11, u);
      return lerp(nx0, nx1, v);
    }
    function resolveOverlaps(rects, width, height, opts = {}) {
      const iterations = opts.iterations ?? 100;
      const padding = opts.padding ?? 6;
      for (let k = 0; k < iterations; k++) {
        let moved = false;
        for (let i = 0; i < rects.length; i++) {
          for (let j = i + 1; j < rects.length; j++) {
            const a = rects[i], b = rects[j];
            const ax = a.x + a.width/2, ay = a.y + a.height/2;
            const bx = b.x + b.width/2, by = b.y + b.height/2;
            const dx = ax - bx, dy = ay - by;
            const overlapX = (a.width/2 + b.width/2 + padding) - Math.abs(dx);
            const overlapY = (a.height/2 + b.height/2 + padding) - Math.abs(dy);
            if (overlapX > 0 && overlapY > 0) {
              moved = true;
              const pushX = 0.6 * overlapX * Math.sign(dx || (Math.random() - 0.5));
              const pushY = 0.6 * overlapY * Math.sign(dy || (Math.random() - 0.5));
              a.x += pushX * 0.5; b.x -= pushX * 0.5;
              a.y += pushY * 0.5; b.y -= pushY * 0.5;
              a.x = Math.max(MARGINS.left, Math.min(a.x, width - MARGINS.right - a.width));
              b.x = Math.max(MARGINS.left, Math.min(b.x, width - MARGINS.right - b.width));
              a.y = Math.max(MARGINS.top, Math.min(a.y, height - MARGINS.bottom - a.height));
              b.y = Math.max(MARGINS.top, Math.min(b.y, height - MARGINS.bottom - b.height));
            }
          }
        }
        if (!moved) break;
      }
      return rects;
    }

    // Pattern generators
    function randIn(min, max){ return min + Math.random()*(max-min); } // only for cluster-sign fallback

    function generateScatterPositions(count, width, height, texts) {
      const positions = [];
      const padding = 15, maxAttempts = 150, checkboxHeight = MARGINS.checkboxH;
      const clusterProbability = Math.max(0.3, Math.min(0.5, new SeededRandom(currentSeed+17).randomFloat ? new SeededRandom(currentSeed+17).randomFloat(0.3,0.5) : 0.4));
      const clusterCount = Math.max(2, Math.floor(count / 5));
      const clusterRadius = 80;
      currentParams = { clusterProb: clusterProbability, clusters: clusterCount, radius: clusterRadius };
      const clusters = [];
      const minX = MARGINS.left, maxX = width - MARGINS.right;
      const minY = MARGINS.top, maxY = height - MARGINS.bottom;
      for (let i = 0; i < clusterCount; i++) clusters.push({ x: randIn(minX, maxX), y: randIn(minY, maxY) });
      for (let i = 0; i < count; i++) {
        const boxWidth = measureTextWidth(texts[i]);
        let pos, attempts = 0, valid = false;
        const inCluster = Math.random() < clusterProbability && clusters.length > 0;
        while (!valid && attempts < maxAttempts) {
          if (inCluster) {
            const c = clusters[Math.floor(Math.random()*clusters.length)];
            const a = Math.random() * Math.PI * 2, d = Math.random() * clusterRadius;
            pos = { x: c.x + Math.cos(a)*d, y: c.y + Math.sin(a)*d, width: boxWidth, height: checkboxHeight };
          } else {
            pos = { x: randIn(minX, maxX - boxWidth), y: randIn(minY, maxY - checkboxHeight), width: boxWidth, height: checkboxHeight };
          }
          pos.x = Math.max(minX, Math.min(pos.x, maxX - boxWidth));
          pos.y = Math.max(minY, Math.min(pos.y, maxY - checkboxHeight));
          valid = true;
          for (let e of positions) {
            if (!(
              pos.x + pos.width + padding < e.x || e.x + e.width + padding < pos.x ||
              pos.y + pos.height + padding < e.y || e.y + e.height + padding < pos.y
            )) { valid = false; break; }
          }
          attempts++;
        }
        positions.push(pos);
      }
      return positions;
    }

    function generateListPositions(count, width, height, texts) {
      const positions = [];
      const checkboxHeight = MARGINS.checkboxH;
      const sublistCount = 5, lineSpacing = 40;
      const nestingProbability = 0.2, indentSize = 30;
      currentParams = { sublists: sublistCount, lineSpacing, indentSize, nesting: (nestingProbability*100).toFixed(0)+'%' };
      const itemsPerSublist = []; let remaining = count;
      for (let i = 0; i < sublistCount; i++) {
        if (i === sublistCount - 1) itemsPerSublist.push(remaining);
        else { const size = Math.max(2, Math.floor(remaining / (sublistCount - i))); itemsPerSublist.push(Math.min(size, remaining)); remaining -= itemsPerSublist[i]; }
      }
      const bounds = []; const maxAttempts = 50; const maxW = 360;
      for (let i = 0; i < sublistCount; i++) {
        let valid = false, attempts = 0, x, y;
        const w = maxW, h = itemsPerSublist[i] * lineSpacing + 20;
        while (!valid && attempts < maxAttempts) {
          x = Math.max(MARGINS.left, Math.min(randIn(MARGINS.left, width - MARGINS.right - w), width - MARGINS.right - w));
          y = Math.max(MARGINS.top, Math.min(randIn(MARGINS.top, height - MARGINS.bottom - h), height - MARGINS.bottom - h));
          valid = true;
          for (let e of bounds) {
            const p = 30;
            if (!(x + w + p < e.x || e.x + e.width + p < x || y + h + p < e.y || e.y + e.height + p < y)) { valid = false; break; }
          }
          attempts++;
        }
        bounds.push({ x, y, width: w, height: h });
      }
      let textIdx = 0;
      for (let s = 0; s < sublistCount; s++) {
        const baseX = bounds[s].x; let currentY = bounds[s].y;
        for (let i = 0; i < itemsPerSublist[s]; i++) {
          if (textIdx >= count) break;
          const isNested = i > 0 && Math.random() < nestingProbability;
          const indent = isNested ? indentSize : 0;
          const x = baseX + indent;
          const boxWidth = Math.min( measureTextWidth(texts[textIdx]), maxW - indent );
          positions.push({ x, y: currentY, width: boxWidth, height: checkboxHeight, isNested, sublistId: s });
          currentY += lineSpacing;
          textIdx++;
        }
      }
      return positions;
    }

    function generateCirclePositions(count, width, height, texts) {
      const positions = [];
      const centerX = width / 2, centerY = (height + MARGINS.top) / 2;
      const checkboxHeight = MARGINS.checkboxH;
      const baseRadius = Math.min(width - MARGINS.left - MARGINS.right, height - MARGINS.top - MARGINS.bottom) * 0.35;
      const radiusVariation = 0.1;
      const rotationOffset = Math.PI * 0.25;
      const ellipseRatio = 1.0;
      currentParams = { radius: baseRadius, variation: radiusVariation, rotation: (rotationOffset*180/Math.PI).toFixed(0)+'¬∞', ellipse: ellipseRatio };
      for (let i = 0; i < count; i++) {
        const angle = rotationOffset + (i / count) * Math.PI * 2;
        const radius = baseRadius * (1 + (Math.random()*2 - 1) * radiusVariation);
        const boxWidth = measureTextWidth(texts[i]);
        const x = centerX + Math.cos(angle) * radius * ellipseRatio - boxWidth / 2;
        const y = centerY + Math.sin(angle) * radius - checkboxHeight / 2;
        positions.push({ x, y, width: boxWidth, height: checkboxHeight });
      }
      return positions;
    }

    function generateSpiralPositions(count, width, height, texts) {
      const positions = [];
      const centerX = width / 2, centerY = (height + MARGINS.top) / 2;
      const checkboxHeight = MARGINS.checkboxH;
      const startAngle = Math.PI * 0.1;
      const maxRadius = Math.min(width - MARGINS.left - MARGINS.right, height - MARGINS.top - MARGINS.bottom) * 0.48;
      const minRadius = 35;
      const tight = 0.2;
      currentParams = { startAngle: (startAngle*180/Math.PI).toFixed(0)+'¬∞', maxR: maxRadius.toFixed(0), minR: minRadius.toFixed(0), tightness: tight.toFixed(2) };
      const path = []; const steps = count * 3;
      for (let i = 0; i < steps; i++) {
        const t = i / (steps - 1);
        const a = startAngle + t * Math.PI * 6 * (1 / tight);
        const r = maxRadius * Math.exp(-tight * t * 20);
        if (r < minRadius) break;
        path.push({ x: centerX + Math.cos(a)*r, y: centerY + Math.sin(a)*r });
      }
      let idx = 0;
      for (let i = 0; i < count; i++) {
        if (idx >= path.length) break;
        const boxWidth = measureTextWidth(texts[i]);
        const p = path[idx];
        positions.push({ x: p.x - boxWidth/2, y: p.y - checkboxHeight/2, width: boxWidth, height: checkboxHeight });
        idx += Math.max(1, Math.floor(path.length / (count * 1.5)));
      }
      return positions;
    }

    function generateGridNoisePositions(count, width, height, texts) {
      const positions = [];
      const checkboxHeight = MARGINS.checkboxH;
      const cols = Math.ceil(Math.sqrt(count * (width / height)));
      const rows = Math.ceil(count / cols);
      let maxTextWidth = 0;
      for (let text of texts) maxTextWidth = Math.max(maxTextWidth, measureTextWidth(text));
      const cellWidth = Math.max((width - MARGINS.left - MARGINS.right) / cols, maxTextWidth + 20);
      const cellHeight = Math.max((height - MARGINS.top - MARGINS.bottom) / rows, 50);
      const scale = 0.3;
      const strength = 48;
      currentParams = { cols, rows, noiseScale: Number(scale.toFixed(2)), noiseStr: Number(strength.toFixed(1)) };
      let index = 0;
      for (let row = 0; row < rows && index < count; row++) {
        for (let col = 0; col < cols && index < count; col++) {
          const boxWidth = measureTextWidth(texts[index]);
          const baseX = MARGINS.left + col*cellWidth + cellWidth/2 - boxWidth/2;
          const baseY = MARGINS.top + row*cellHeight + cellHeight/2 - checkboxHeight/2;
          const nX = noise2D(col, row, scale);
          const nY = noise2D(col + 1000, row + 1000, scale);
          const x = baseX + (nX - 0.5) * strength;
          const y = baseY + (nY - 0.5) * strength;
          positions.push({ x: Math.max(MARGINS.left, Math.min(x, width - MARGINS.right - boxWidth)), y: Math.max(MARGINS.top, Math.min(y, height - MARGINS.bottom - checkboxHeight)), width: boxWidth, height: checkboxHeight });
          index++;
        }
      }
      return positions;
    }

    function generateLetterPositions(count, width, height, texts) {
      const positions = [];
      const checkboxHeight = MARGINS.checkboxH;
      const centerX = width / 2, centerY = (height + MARGINS.top) / 2;
      const letters = ['D','G','T'];
      const chosenLetter = letters[(readSeed() ? parseInt(readSeed(),10) : 0) % letters.length];
      let baseScale = 0.55;
      if (chosenLetter === 'T') baseScale = 0.6;
      const letterScale = Math.min(width - MARGINS.left - MARGINS.right, height - MARGINS.top - MARGINS.bottom) * baseScale;
      const rotation = 0;
      const pointSpacing = 1.6;
      currentParams = { letter: chosenLetter, scale: letterScale.toFixed(0), rotation: rotation.toFixed(0)+'¬∞', spacing: pointSpacing.toFixed(2) };
      const points = [];
      if (chosenLetter === 'D') {
        const verticalPoints = Math.floor(count * 0.4);
        for (let i = 0; i < verticalPoints; i++) {
          const t = i / Math.max(verticalPoints - 1, 1);
          points.push({ x: -letterScale * 0.5, y: -letterScale + t * letterScale * 2 });
        }
        const arcPoints = count - verticalPoints;
        for (let i = 0; i < arcPoints; i++) {
          const t = i / Math.max(arcPoints - 1, 1);
          const angle = -Math.PI/2 + t * Math.PI;
          points.push({ x: -letterScale * 0.5 + Math.cos(angle) * letterScale * 0.75, y: Math.sin(angle) * letterScale });
        }
      } else if (chosenLetter === 'G') {
        const arcPoints = Math.floor(count * 0.5);
        for (let i = 0; i < arcPoints; i++) {
          const angle = Math.PI * 0.6 + (i / Math.max(arcPoints - 1, 1)) * Math.PI * 1.6;
          points.push({ x: Math.cos(angle) * letterScale * 0.65, y: Math.sin(angle) * letterScale * 0.65 - letterScale * 0.1 });
        }
        const barPoints = Math.floor(count * 0.25);
        for (let i = 0; i < barPoints; i++) {
          const t = i / Math.max(barPoints - 1, 1);
          points.push({ x: t * letterScale * 0.5, y: letterScale * 0.15 });
        }
        for (let i = points.length; i < count; i++) {
          const angle = Math.random() * Math.PI * 1.5 + Math.PI * 0.5;
          const r = letterScale * (0.4 + Math.random() * 0.3);
          points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r - letterScale * 0.1 });
        }
      } else {
        const topPoints = Math.floor(count * 0.4);
        for (let i = 0; i < topPoints; i++) {
          const t = i / Math.max(topPoints - 1, 1);
          points.push({ x: (t - 0.5) * letterScale * 1.4, y: -letterScale * 0.65 });
        }
        const stemPoints = count - topPoints;
        for (let i = 0; i < stemPoints; i++) {
          const t = i / Math.max(stemPoints - 1, 1);
          points.push({ x: 0, y: -letterScale * 0.65 + t * letterScale * 1.5 });
        }
      }
      shuffleArraySeeded(points, new SeededRandom(currentSeed+123));
      for (let i = 0; i < count; i++) {
        const boxWidth = measureTextWidth(texts[i]);
        const p = points[i] || points[0];
        positions.push({ x: centerX + p.x * pointSpacing - boxWidth / 2, y: centerY + p.y * pointSpacing - checkboxHeight / 2, width: boxWidth, height: checkboxHeight });
      }
      return positions;
    }

    function generatePhyllotaxisPositions(count, width, height, texts) {
      const positions = [];
      const cx = width / 2, cy = (height + MARGINS.top) / 2, checkboxHeight = MARGINS.checkboxH;
      const R = Math.min(width - MARGINS.left - MARGINS.right, height - MARGINS.top - MARGINS.bottom) * 0.45;
      const golden = Math.PI * (3 - Math.sqrt(5));
      const jitter = 6;
      currentParams = { radius: Number(R.toFixed(0)), jitter: Number(jitter.toFixed(1)) };
      for (let i = 0; i < count; i++) {
        const r = R * Math.sqrt(i / count);
        const a = i * golden;
        const w = measureTextWidth(texts[i]);
        const x = cx + Math.cos(a) * r + (Math.random()*2 - 1) * jitter - w / 2;
        const y = cy + Math.sin(a) * r + (Math.random()*2 - 1) * jitter - checkboxHeight / 2;
        positions.push({ x, y, width: w, height: checkboxHeight });
      }
      return positions;
    }

    function generateLissajousPositions(count, width, height, texts) {
      const positions = [];
      const cx = width / 2, cy = (height + MARGINS.top) / 2, checkboxHeight = MARGINS.checkboxH;
      const Ax = Math.min(width - MARGINS.left - MARGINS.right, height - MARGINS.top - MARGINS.bottom) * 0.4;
      const Ay = Ax;
      const a = 3, b = 4;
      const delta = Math.PI * 0.25;
      currentParams = { Ax: Number(Ax.toFixed(0)), Ay: Number(Ay.toFixed(0)), a, b, delta: (delta*180/Math.PI).toFixed(0) + '¬∞' };
      for (let i = 0; i < count; i++) {
        const t = i / count * Math.PI * 2;
        const w = measureTextWidth(texts[i]);
        const x = cx + Ax * Math.sin(a * t + delta) - w / 2;
        const y = cy + Ay * Math.sin(b * t) - checkboxHeight / 2;
        positions.push({ x, y, width: w, height: checkboxHeight });
      }
      return positions;
    }

    // ======================= Events =======================
    function onCheckboxChange(e) { checkedCount += e.target.checked ? 1 : -1; updateProgress(); checkCompletion(); }
    function updateProgress() {
      const percentage = totalCount > 0 ? (checkedCount / totalCount) * 100 : 0;
      document.getElementById('progress-fill').style.width = `${percentage}%`;
      document.getElementById('progress-text').textContent = `${checkedCount} / ${totalCount}`;
    }
    function checkCompletion() { if (checkedCount === totalCount && totalCount > 0) showCompletionScreen(); }

    // ======================= Confetti: dynamic mount to BODY =======================
    let confettiCanvas = null, confettiCtx = null, confettiParticles = [], confettiActive = false, confettiRAF = null;
    function ensureConfettiCanvas() {
      if (confettiCanvas && confettiCtx) return;
      confettiCanvas = document.createElement('canvas');
      confettiCanvas.className = 'gtd-confetti';
      confettiCanvas.setAttribute('aria-hidden', 'true');
      document.body.appendChild(confettiCanvas);
      confettiCtx = confettiCanvas.getContext('2d');
      sizeConfettiCanvas();
      window.addEventListener('resize', sizeConfettiCanvas);
    }
    function sizeConfettiCanvas() { if (!confettiCanvas) return; confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; }
    class ConfettiParticle {
      constructor() {
        this.x = Math.random() * confettiCanvas.width;
        this.y = -20;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = Math.random() * 3 + 2;
        this.size = Math.random() * 8 + 4;
        this.color = randomFromArray(['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181']);
        this.rotation = Math.random() * 360;
        this.rotationSpeed = (Math.random() - 0.5) * 10;
        this.gravity = 0.1;
      }
      update() { this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.rotation += this.rotationSpeed; }
      draw() {
        confettiCtx.save();
        confettiCtx.translate(this.x, this.y);
        confettiCtx.rotate(this.rotation * Math.PI / 180);
        confettiCtx.fillStyle = this.color;
        confettiCtx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        confettiCtx.restore();
      }
      isOffScreen() { return this.y > confettiCanvas.height + 20; }
    }
    function startConfetti() {
      ensureConfettiCanvas();
      confettiActive = true;
      confettiParticles = [];
      for (let i = 0; i < 100; i++) confettiParticles.push(new ConfettiParticle());
      animateConfetti();
    }
    function stopConfetti() {
      confettiActive = false;
      confettiParticles = [];
      if (confettiRAF) cancelAnimationFrame(confettiRAF);
      if (confettiCtx) confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    }
    function animateConfetti() {
      if (!confettiActive || !confettiCtx) return;
      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      if (Math.random() < 0.3 && confettiParticles.length < 150) confettiParticles.push(new ConfettiParticle());
      confettiParticles = confettiParticles.filter(p => { p.update(); p.draw(); return !p.isOffScreen(); });
      if (confettiParticles.length === 0) { stopConfetti(); return; }
      confettiRAF = requestAnimationFrame(animateConfetti);
    }

    // ======================= Completion UI =======================
    function showCompletionScreen() {
      const today = new Date();
      const dateStr = today.toLocaleDateString('en-US',{year:'numeric',month:'long',day:'numeric'});
      document.getElementById('badge').textContent = `‚úì ${dateStr}`;
      document.getElementById('certificate-date').textContent = dateStr;
      document.getElementById('completion-screen').classList.add('active');
      document.getElementById('certificate').classList.remove('show');
      document.getElementById('name-input-container').style.display = 'block';
      document.getElementById('badge').style.display = 'block';
      document.getElementById('completion-message').style.display = 'block';
      document.getElementById('completion-submessage').style.display = 'block';
      startConfetti();
      setTimeout(() => {
        const input = document.getElementById('name-input');
        input.focus();
        input.onkeydown = e => { if (e.key === 'Enter' && input.value.trim()) showCertificate(input.value.trim()); };
      }, 250);
    }
    function showCertificate(name) {
      document.getElementById('name-input-container').style.display = 'none';
      document.getElementById('badge').style.display = 'none';
      document.getElementById('completion-message').style.display = 'none';
      document.getElementById('completion-submessage').style.display = 'none';
      document.getElementById('certificate-name').textContent = name;
      document.getElementById('certificate-task-count').textContent = totalCount;
      document.getElementById('certificate').classList.add('show');
    }
    function hideCompletionScreen() {
      document.getElementById('completion-screen').classList.remove('active');
      document.getElementById('name-input').value = '';
      document.getElementById('certificate').classList.remove('show');
    }

    // ======================= Misc utils/events =======================
    function clearCheckboxes() { const container = document.getElementById('checkboxes-container'); container.innerHTML = ''; checkboxes = []; }
    function reset() { init(); }
    function shuffleArraySeeded(arr, rng) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(rng.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
    function randomFromArray(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    let __resizeT;
    window.addEventListener('resize', () => { clearTimeout(__resizeT); __resizeT = setTimeout(() => { if (confettiCanvas) sizeConfettiCanvas(); reset(); }, 200); });
    document.addEventListener('visibilitychange', () => { if (!document.hidden) reset(); }, { once: true });
    document.addEventListener('keydown', (e) => { if (e.target.tagName === 'INPUT') return; if (e.key.toLowerCase() === 'r') reset(); });

    // Drag debug
    const debugPanel = document.getElementById('debug-panel');
    let isDragging = false, dragOffsetX = 0, dragOffsetY = 0;
    debugPanel.addEventListener('mousedown', (e) => { if (e.target.id === 'reset-button') return; isDragging = true; dragOffsetX = e.clientX - debugPanel.offsetLeft; dragOffsetY = e.clientY - debugPanel.offsetTop; });
    document.addEventListener('mousemove', (e) => { if (!isDragging) return; debugPanel.style.left = (e.clientX - dragOffsetX) + 'px'; debugPanel.style.top = (e.clientY - dragOffsetY) + 'px'; debugPanel.style.right = 'auto'; });
    document.addEventListener('mouseup', () => { isDragging = false; });
    document.getElementById('reset-button').addEventListener('click', reset);

    // Start
    safeInit();
  </script>
</body>
</html>
