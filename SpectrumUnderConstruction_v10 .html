<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Spectrum Under Construction v10.4</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --panel-bg: rgba(0,0,0,0.92);
      --panel-border: #ff006e;
      --label: #9ca3af;
      --title: #f5f5f5;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      overflow:hidden;
      background:#0a0a0a;
      font-family:'Roboto',system-ui,sans-serif;
    }
    canvas {
      display:block;
      width:100vw;
      height:100vh;
      background:#c8c8c8;
      image-rendering:pixelated;
    }
    #controls {
      position:fixed;
      top:20px;
      left:50%;
      transform:translateX(-50%);
      z-index:10;
      background:var(--panel-bg);
      border:2px solid var(--panel-border);
      border-radius:10px;
      padding:0 16px 14px 16px;
      color:white;
      width:520px;
    }
    #dragBar {
      display:flex;
      align-items:center;
      gap:8px;
      padding:10px 0 8px 0;
      cursor:grab;
      user-select:none;
    }
    #dragSquare {
      width:14px;
      height:14px;
      background:#ff006e;
      border-radius:3px;
    }
    #dragLabel {
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:#d1d5db;
    }
    h2 {
      font-size:15px;
      font-weight:500;
      text-align:left;
      margin-bottom:10px;
      color:var(--title);
    }
    #panelGrid {
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px 12px;
      align-items:start;
    }
    .group-title {
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.05em;
      color:white;
      margin-bottom:4px;
      font-weight:500;
    }
    .slider-group { margin-bottom:6px; }
    .slider-group label {
      display:flex;
      justify-content:space-between;
      font-size:10px;
      color:var(--label);
      margin-bottom:3px;
      text-transform:uppercase;
      letter-spacing:.04em;
    }
    input[type="range"] { width:100%; }
    input[type="color"] {
      width:100%;
      height:26px;
      border:none;
      border-radius:4px;
      margin-top:3px;
      background:transparent;
    }
    button {
      background:linear-gradient(135deg,#ff006e,#8ac926);
      border:none;
      color:white;
      padding:7px 12px;
      font-size:10px;
      margin-right:6px;
      border-radius:4px;
      text-transform:uppercase;
      letter-spacing:.05em;
      font-weight:500;
      cursor:pointer;
    }
    button:disabled { background:#333; cursor:not-allowed; }
    select {
      width:100%;
      background:#0f172a;
      color:white;
      border:1px solid #1f2937;
      border-radius:4px;
      height:26px;
      font-size:11px;
    }
    .palette-preview {
      height:10px;
      border-radius:3px;
      border:1px solid rgba(255,255,255,0.15);
      margin-top:4px;
    }
    #specBar {
      width:100%;
      height:50px;
      background:#111;
      border:1px solid rgba(255,255,255,0.07);
      margin-top:6px;
      image-rendering:pixelated;
      grid-column:1 / span 2;
    }
    #status {
      font-size:10px;
      color:#9ca3af;
      margin-top:4px;
      grid-column:1 / span 2;
    }
    #fps {
      position:fixed;
      bottom:10px;
      left:10px;
      background:rgba(0,0,0,0.55);
      color:white;
      font-size:10px;
      padding:3px 8px;
      border-radius:4px;
      z-index:20;
      font-family:monospace;
    }
    .checkbox-line {
      display:flex;
      align-items:center;
      gap:6px;
      font-size:10px;
      color:var(--label);
      margin-bottom:4px;
      text-transform:uppercase;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="controls">
    <div id="dragBar">
      <div id="dragSquare"></div>
      <div id="dragLabel">H hide panel</div>
    </div>
    <h2>Spectrum v10.4</h2>
    <div id="panelGrid">
      <div>
        <div class="group-title">audio</div>
        <div class="slider-group">
          <label><span>mic/file</span></label>
          <button id="micBtn">mic</button>
          <button id="fileBtn">file</button>
          <input id="fileInput" type="file" accept="audio/*" style="display:none">
        </div>
        <div class="slider-group">
          <label>signal x<span id="gainValue">0.5</span></label>
          <input id="gainSlider" type="range" min="0.5" max="10" step="0.5" value="0.5">
        </div>
        <div class="slider-group">
          <label>file volume<span id="fileVolValue">0.90</span></label>
          <input id="fileVolSlider" type="range" min="0" max="1.5" step="0.05" value="0.9">
        </div>

        <div class="group-title" style="margin-top:8px;">scene & spectrum</div>
        <div class="slider-group">
          <label>container scale<span id="containerScaleValue">0.55x</span></label>
          <input id="containerScaleSlider" type="range" min="0.4" max="1.2" step="0.05" value="0.55">
        </div>
        <div class="slider-group">
          <label>spec offset<span id="specOffsetValue">-65</span></label>
          <input id="specOffsetSlider" type="range" min="-512" max="512" step="1" value="-65">
        </div>
        <div class="slider-group">
          <label>spec scale<span id="specScaleValue">0.8x</span></label>
          <input id="specScaleSlider" type="range" min="0.2" max="3" step="0.1" value="0.8">
        </div>
        <div class="slider-group">
          <label>shuffle speed<span id="shuffleValue">0.3s</span></label>
          <input id="shuffleSlider" type="range" min="0.1" max="10" step="0.1" value="0.3">
        </div>
        <div class="slider-group">
          <label>silence thr<span id="thresholdValue">0.05</span></label>
          <input id="thresholdSlider" type="range" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>

        <div class="group-title" style="margin-top:8px;">background / grid</div>
        <div class="slider-group">
          <label>bg color A</label>
          <input id="bgColorA" type="color" value="#d4d4d4">
        </div>
        <div class="slider-group">
          <label>bg color B</label>
          <input id="bgColorB" type="color" value="#d4d4d4">
        </div>
        <div class="slider-group">
          <label>bg radial scale<span id="bgRadialValue">1.0x</span></label>
          <input id="bgRadialSlider" type="range" min="0.3" max="2" step="0.05" value="1">
        </div>
        <div class="checkbox-line">
          <input id="showGrid" type="checkbox" checked>
          <label for="showGrid">show grid</label>
        </div>
        <div id="gridControls">
          <div class="slider-group">
            <label>grid step x<span id="gridStepXValue">200px</span></label>
            <input id="gridStepXSlider" type="range" min="20" max="200" step="5" value="200">
          </div>
          <div class="slider-group">
            <label>grid step y<span id="gridStepYValue">200px</span></label>
            <input id="gridStepYSlider" type="range" min="20" max="200" step="5" value="200">
          </div>
          <div class="slider-group">
            <label>grid offset x<span id="gridOffXValue">0px</span></label>
            <input id="gridOffXSlider" type="range" min="-200" max="200" step="5" value="0">
          </div>
          <div class="slider-group">
            <label>grid offset y<span id="gridOffYValue">0px</span></label>
            <input id="gridOffYSlider" type="range" min="-200" max="200" step="5" value="0">
          </div>
          <div class="slider-group">
            <label>grid color offset<span id="gridColorOffValue">0.00</span></label>
            <input id="gridColorOffSlider" type="range" min="0" max="1" step="0.01" value="0">
          </div>
          <div class="slider-group">
            <label>grid color A</label>
            <input id="gridColorA" type="color" value="#000000">
          </div>
          <div class="slider-group">
            <label>grid color B</label>
            <input id="gridColorB" type="color" value="#ff006e">
          </div>
        </div>
      </div>

      <div>
        <div class="group-title">block 1 (vertical)</div>
        <div class="slider-group">
          <label>cell size<span id="sizeValue">1.8x</span></label>
          <input id="sizeSlider" type="range" min="0.5" max="3" step="0.1" value="1.8">
        </div>
        <div class="slider-group">
          <label>hide %<span id="hideValue">89%</span></label>
          <input id="hideSlider" type="range" min="0" max="100" step="1" value="89">
        </div>
        <div class="slider-group">
          <label>row offset<span id="blockOffsetValue">0</span></label>
          <input id="blockOffsetSlider" type="range" min="0" max="200" step="1" value="0">
        </div>
        <div class="slider-group">
          <label>block 1 scale<span id="blockScaleValue">0.3x</span></label>
          <input id="blockScaleSlider" type="range" min="0.3" max="1.6" step="0.1" value="0.3">
        </div>
        <div class="slider-group">
          <label>stroke base<span id="strokeValue">2px</span></label>
          <input id="strokeSlider" type="range" min="0" max="20" step="1" value="2">
        </div>
        <div class="slider-group">
          <label>stroke random<span id="strokeRndValue">600px</span></label>
          <input id="strokeRndSlider" type="range" min="0" max="2000" step="10" value="600">
        </div>
        <div class="slider-group">
          <label>block palette</label>
          <select id="blockPaletteSelect"></select>
          <div id="blockPalettePreview" class="palette-preview"></div>
        </div>

        <div class="group-title" style="margin-top:8px;">block 2 (horizontal)</div>
        <div class="slider-group">
          <label>hide %<span id="b2HideValue">18%</span></label>
          <input id="b2HideSlider" type="range" min="0" max="100" step="1" value="18">
        </div>
        <div class="slider-group">
          <label>row offset<span id="b2OffsetValue">7</span></label>
          <input id="b2OffsetSlider" type="range" min="0" max="200" step="1" value="7">
        </div>
        <div class="slider-group">
          <label>density<span id="b2DensityValue">0.20</span></label>
          <input id="b2DensitySlider" type="range" min="0" max="1" step="0.05" value="0.20">
        </div>
        <div class="slider-group">
          <label>length<span id="b2LengthValue">0.20</span></label>
          <input id="b2LengthSlider" type="range" min="0.1" max="1" step="0.05" value="0.20">
        </div>
        <div class="slider-group">
          <label>block 2 scale<span id="b2ScaleValue">2.0x</span></label>
          <input id="b2ScaleSlider" type="range" min="0.3" max="2" step="0.1" value="2.0">
        </div>
        <div class="slider-group">
          <label>stripe stroke base<span id="b2StrokeValue">1px</span></label>
          <input id="b2StrokeSlider" type="range" min="0" max="10" step="1" value="1">
        </div>
        <div class="slider-group">
          <label>stripe stroke random<span id="b2StrokeRndValue">0px</span></label>
          <input id="b2StrokeRndSlider" type="range" min="0" max="50" step="1" value="0">
        </div>
        <div class="slider-group">
          <label>stripe palette</label>
          <select id="stripePaletteSelect"></select>
          <div id="stripePalettePreview" class="palette-preview"></div>
        </div>
      </div>

      <canvas id="specBar" width="512" height="50"></canvas>
      <div id="status">click mic or file</div>
    </div>
  </div>

  <div id="fps">fps: 0</div>

  <script>
    const PALETTES = {
      neon_magenta_cyan: ['#020617','#ff008c','#00f6ff','#ffffff'],
      mono_mint: ['#000000','#0f172a','#1f2937','#6ee7b7','#ecfdf3'],
      teal_pink: ['#000000','#190015','#4a001c','#a6004b','#ff007f'],
      violet_orange: ['#020617','#312e81','#a855f7','#f97316','#ffedd5']
    };

    const DPR = 1;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const specCanvas = document.getElementById('specBar');
    const specCtx = specCanvas.getContext('2d');
    specCtx.imageSmoothingEnabled = false;

    const controls = document.getElementById('controls');
    const dragBar = document.getElementById('dragBar');

    let audioContext, analyser, visGainNode, fileGainNode, dataArray;
    let isPlaying = false;
    let micSource = null;
    let fileSource = null;

    const CONFIG = {
      numBars: 512,
      numGroups: 4,
      barsPerGroup: 128,
      containerScale: 0.55,
      shuffleInterval: 300,
      silenceThreshold: 0.05,
      signalGain: 0.5,
      fileVolume: 0.9,
      cellRatio: 0.012,
      cellScale: 1.8,
      hidePercentBlocks: 89,
      blockOffsetRows: 0,
      blockScale: 0.3,
      specOffset: -65,
      specScale: 0.8,
      bgColorA: '#d4d4d4',
      bgColorB: '#d4d4d4',
      bgRadialScale: 1.0,
      gridStepX: 200,
      gridStepY: 200,
      gridOffsetX: 0,
      gridOffsetY: 0,
      gridColorA: '#000000',
      gridColorB: '#ff006e',
      gridColorOffset: 0,
      showGrid: true,
      strokeWidth: 2,
      strokeRandomMax: 600,
      groupShuffleSizes: [32,8,4,128],
      groupSilence: [
        'rgba(0,0,0,0)',
        'rgba(0,0,0,0)',
        'rgba(0,0,0,0)',
        '#000000'
      ]
    };

    const BLOCK2 = {
      hidePercent: 18,
      offset: 7,
      scale: 2.0,
      lengthFactor: 0.20,
      density: 0.20,
      strokeWidth: 1,
      strokeRandom: 0
    };

    let currentBlockPalette = PALETTES.teal_pink;
    let currentStripePalette = PALETTES.violet_orange;

    let bars = [];
    let groups = [];
    let displayBars = [];
    let grid = {cols:0, rows:0, cellW:0, cellH:0, startX:0, startY:0, contentW:0, contentH:0};
    let drawRects = [];
    let block2Seeds = [];
    let gridColorPhase = 0;

    let lastShuffleTime = 0;
    let lastFrameTime = performance.now();
    let controlsVisible = true;

    function resizeCanvas() {
      canvas.width = Math.floor(window.innerWidth * DPR);
      canvas.height = Math.floor(window.innerHeight * DPR);
      if (bars.length) buildGrid();
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // draggable
    (function(){
      let isDown=false, ox=0, oy=0;
      dragBar.addEventListener('mousedown', e=>{
        isDown=true;
        const rect = controls.getBoundingClientRect();
        ox = e.clientX - rect.left;
        oy = e.clientY - rect.top;
        dragBar.style.cursor='grabbing';
        controls.style.transform='none';
      });
      document.addEventListener('mousemove', e=>{
        if (!isDown) return;
        controls.style.left = (e.clientX - ox) + 'px';
        controls.style.top = (e.clientY - oy) + 'px';
      });
      document.addEventListener('mouseup', ()=>{ isDown=false; dragBar.style.cursor='grab'; });
    })();

    document.addEventListener('keydown', e=>{
      if (e.key==='h' || e.key==='H') {
        controlsVisible = !controlsVisible;
        controls.style.display = controlsVisible ? 'block' : 'none';
      }
    });

    // fill palettes
    const blockPaletteSelect = document.getElementById('blockPaletteSelect');
    const stripePaletteSelect = document.getElementById('stripePaletteSelect');
    for (const key in PALETTES) {
      const o1=document.createElement('option'); o1.value=key; o1.textContent=key; blockPaletteSelect.appendChild(o1);
      const o2=document.createElement('option'); o2.value=key; o2.textContent=key; stripePaletteSelect.appendChild(o2);
    }
    blockPaletteSelect.value='teal_pink';
    stripePaletteSelect.value='violet_orange';

    function updatePalettePreview(el,palette){
      el.style.background=`linear-gradient(90deg, ${palette.join(',')})`;
    }
    updatePalettePreview(document.getElementById('blockPalettePreview'), currentBlockPalette);
    updatePalettePreview(document.getElementById('stripePalettePreview'), currentStripePalette);

    // UI bindings
    document.getElementById('gainSlider').oninput = e => {
      CONFIG.signalGain = +e.target.value;
      if (visGainNode) visGainNode.gain.value = CONFIG.signalGain;
      document.getElementById('gainValue').textContent = CONFIG.signalGain.toFixed(1);
    };
    document.getElementById('fileVolSlider').oninput = e => {
      CONFIG.fileVolume = +e.target.value;
      if (fileGainNode) fileGainNode.gain.value = CONFIG.fileVolume;
      document.getElementById('fileVolValue').textContent = CONFIG.fileVolume.toFixed(2);
    };
    document.getElementById('containerScaleSlider').oninput = e => {
      CONFIG.containerScale = +e.target.value;
      document.getElementById('containerScaleValue').textContent = CONFIG.containerScale.toFixed(2)+'x';
      buildGrid();
    };
    document.getElementById('specOffsetSlider').oninput = e => {
      CONFIG.specOffset = +e.target.value;
      document.getElementById('specOffsetValue').textContent = CONFIG.specOffset;
    };
    document.getElementById('specScaleSlider').oninput = e => {
      CONFIG.specScale = +e.target.value;
      document.getElementById('specScaleValue').textContent = CONFIG.specScale.toFixed(1)+'x';
    };
    document.getElementById('shuffleSlider').oninput = e => {
      CONFIG.shuffleInterval = +e.target.value * 1000;
      document.getElementById('shuffleValue').textContent = (+e.target.value).toFixed(1)+'s';
    };
    document.getElementById('thresholdSlider').oninput = e => {
      CONFIG.silenceThreshold = +e.target.value;
      document.getElementById('thresholdValue').textContent = CONFIG.silenceThreshold.toFixed(2);
    };

    document.getElementById('bgColorA').oninput = e => CONFIG.bgColorA = e.target.value;
    document.getElementById('bgColorB').oninput = e => CONFIG.bgColorB = e.target.value;
    document.getElementById('bgRadialSlider').oninput = e => {
      CONFIG.bgRadialScale = +e.target.value;
      document.getElementById('bgRadialValue').textContent = CONFIG.bgRadialScale.toFixed(1)+'x';
    };

    const showGridCheckbox = document.getElementById('showGrid');
    const gridControls = document.getElementById('gridControls');
    showGridCheckbox.oninput = e=>{
      CONFIG.showGrid = e.target.checked;
      gridControls.style.display = CONFIG.showGrid ? 'block' : 'none';
    };
    document.getElementById('gridStepXSlider').oninput = e=>{
      CONFIG.gridStepX = +e.target.value;
      document.getElementById('gridStepXValue').textContent = CONFIG.gridStepX+'px';
    };
    document.getElementById('gridStepYSlider').oninput = e=>{
      CONFIG.gridStepY = +e.target.value;
      document.getElementById('gridStepYValue').textContent = CONFIG.gridStepY+'px';
    };
    document.getElementById('gridOffXSlider').oninput = e=>{
      CONFIG.gridOffsetX = +e.target.value;
      document.getElementById('gridOffXValue').textContent = CONFIG.gridOffsetX+'px';
    };
    document.getElementById('gridOffYSlider').oninput = e=>{
      CONFIG.gridOffsetY = +e.target.value;
      document.getElementById('gridOffYValue').textContent = CONFIG.gridOffsetY+'px';
    };
    document.getElementById('gridColorOffSlider').oninput = e=>{
      CONFIG.gridColorOffset = +e.target.value;
      document.getElementById('gridColorOffValue').textContent = CONFIG.gridColorOffset.toFixed(2);
    };
    document.getElementById('gridColorA').oninput = e => CONFIG.gridColorA = e.target.value;
    document.getElementById('gridColorB').oninput = e => CONFIG.gridColorB = e.target.value;

    // block1 UI
    document.getElementById('sizeSlider').oninput = e => {
      CONFIG.cellScale = +e.target.value;
      document.getElementById('sizeValue').textContent = CONFIG.cellScale.toFixed(1)+'x';
      buildGrid();
    };
    document.getElementById('hideSlider').oninput = e => {
      CONFIG.hidePercentBlocks = +e.target.value;
      document.getElementById('hideValue').textContent = CONFIG.hidePercentBlocks+'%';
    };
    document.getElementById('blockOffsetSlider').oninput = e => {
      CONFIG.blockOffsetRows = +e.target.value;
      document.getElementById('blockOffsetValue').textContent = CONFIG.blockOffsetRows;
    };
    document.getElementById('blockScaleSlider').oninput = e => {
      CONFIG.blockScale = +e.target.value;
      document.getElementById('blockScaleValue').textContent = CONFIG.blockScale.toFixed(1)+'x';
    };
    document.getElementById('strokeSlider').oninput = e => {
      CONFIG.strokeWidth = +e.target.value;
      document.getElementById('strokeValue').textContent = CONFIG.strokeWidth+'px';
    };
    document.getElementById('strokeRndSlider').oninput = e => {
      CONFIG.strokeRandomMax = +e.target.value;
      document.getElementById('strokeRndValue').textContent = CONFIG.strokeRandomMax+'px';
    };
    blockPaletteSelect.oninput = e => {
      currentBlockPalette = PALETTES[e.target.value];
      updatePalettePreview(document.getElementById('blockPalettePreview'), currentBlockPalette);
    };

    // block2 UI
    document.getElementById('b2HideSlider').oninput = e => {
      BLOCK2.hidePercent = +e.target.value;
      document.getElementById('b2HideValue').textContent = BLOCK2.hidePercent+'%';
    };
    document.getElementById('b2OffsetSlider').oninput = e => {
      BLOCK2.offset = +e.target.value;
      document.getElementById('b2OffsetValue').textContent = BLOCK2.offset;
    };
    document.getElementById('b2DensitySlider').oninput = e => {
      BLOCK2.density = +e.target.value;
      document.getElementById('b2DensityValue').textContent = BLOCK2.density.toFixed(2);
    };
    document.getElementById('b2LengthSlider').oninput = e => {
      BLOCK2.lengthFactor = +e.target.value;
      document.getElementById('b2LengthValue').textContent = BLOCK2.lengthFactor.toFixed(2);
    };
    document.getElementById('b2ScaleSlider').oninput = e => {
      BLOCK2.scale = +e.target.value;
      document.getElementById('b2ScaleValue').textContent = BLOCK2.scale.toFixed(1)+'x';
    };
    document.getElementById('b2StrokeSlider').oninput = e => {
      BLOCK2.strokeWidth = +e.target.value;
      document.getElementById('b2StrokeValue').textContent = BLOCK2.strokeWidth+'px';
    };
    document.getElementById('b2StrokeRndSlider').oninput = e => {
      BLOCK2.strokeRandom = +e.target.value;
      document.getElementById('b2StrokeRndValue').textContent = BLOCK2.strokeRandom+'px';
    };
    stripePaletteSelect.oninput = e => {
      currentStripePalette = PALETTES[e.target.value];
      updatePalettePreview(document.getElementById('stripePalettePreview'), currentStripePalette);
    };

    // audio init
    function initAudio(){
      if (!audioContext){
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0;
        visGainNode = audioContext.createGain();
        visGainNode.gain.value = CONFIG.signalGain;
        fileGainNode = audioContext.createGain();
        fileGainNode.gain.value = CONFIG.fileVolume;
        visGainNode.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
      }
    }

    function initBars(){
      bars=[]; groups=[];
      for (let i=0;i<CONFIG.numBars;i++){
        bars.push({
          id:i,
          freqBin:i,
          energy:0,
          groupIndex:Math.floor(i/CONFIG.barsPerGroup),
          colorA:'rgba(0,0,0,0)',
          colorB:'rgba(0,0,0,0)'
        });
      }
      for (let g=0;g<CONFIG.numGroups;g++){
        const groupBars = bars.filter(b=>b.groupIndex===g);
        groups.push({
          index:g,
          bars:groupBars,
          chunkSize:CONFIG.groupShuffleSizes[g],
          silenceColor:CONFIG.groupSilence[g]
        });
      }
    }

    document.getElementById('micBtn').onclick = async () => {
      try{
        initAudio();
        initBars();
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        micSource = audioContext.createMediaStreamSource(stream);
        micSource.connect(visGainNode);
        isPlaying=true;
        document.getElementById('micBtn').disabled=true;
        document.getElementById('fileBtn').disabled=true;
        document.getElementById('status').textContent='ðŸŽ¤ microphone active';
        if (audioContext.state==='suspended') await audioContext.resume();
        buildGrid();
        animate();
      }catch(err){
        console.error(err);
        document.getElementById('status').textContent='âŒ mic denied';
      }
    };
    document.getElementById('fileBtn').onclick = ()=>document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = async e=>{
      const file=e.target.files[0];
      if (!file) return;
      try{
        initAudio();
        initBars();
        const arr = await file.arrayBuffer();
        const audioBuffer = await new Promise((res,rej)=>audioContext.decodeAudioData(arr,res,rej));
        if (fileSource && fileSource.stop) fileSource.stop();
        fileSource = audioContext.createBufferSource();
        fileSource.buffer=audioBuffer;
        fileSource.loop=true;
        fileSource.connect(visGainNode);
        fileSource.connect(fileGainNode);
        fileGainNode.connect(audioContext.destination);
        fileSource.start(0);
        isPlaying=true;
        document.getElementById('micBtn').disabled=true;
        document.getElementById('fileBtn').disabled=true;
        document.getElementById('status').textContent='ðŸŽµ '+file.name;
        if (audioContext.state==='suspended') await audioContext.resume();
        buildGrid();
        animate();
      }catch(err){
        console.error(err);
        document.getElementById('status').textContent='âŒ file load error';
      }
    };

    function hexToRgb(hex){
      const r=parseInt(hex.slice(1,3),16);
      const g=parseInt(hex.slice(3,5),16);
      const b=parseInt(hex.slice(5,7),16);
      return {r,g,b};
    }
    function lerpColor(c1,c2,t){
      const a=hexToRgb(c1), b=hexToRgb(c2);
      const r=Math.round(a.r+(b.r-a.r)*t);
      const g=Math.round(a.g+(b.g-a.g)*t);
      const bl=Math.round(a.b+(b.b-a.b)*t);
      return `rgb(${r},${g},${bl})`;
    }
    function getColorFromPaletteArr(palette,energy){
      const idx=energy*(palette.length-1);
      const lo=Math.floor(idx);
      const hi=Math.min(lo+1,palette.length-1);
      const t=idx-lo;
      return lerpColor(palette[lo],palette[hi],t);
    }
    function spectrumIndex(i){
      const len=dataArray.length;
      const center=len/2;
      const rel=i-center;
      const scaled=rel*CONFIG.specScale;
      let idx=Math.round(center+scaled+CONFIG.specOffset);
      idx=((idx%len)+len)%len;
      return idx;
    }

    function shuffleGroups(){
      displayBars=[];
      groups.forEach(group=>{
        const groupBars=[...group.bars];
        const chunkSize=group.chunkSize;
        const chunks=[];
        for (let i=0;i<groupBars.length;i+=chunkSize){
          chunks.push(groupBars.slice(i,i+chunkSize));
        }
        for (let i=chunks.length-1;i>0;i--){
          const j=Math.floor(Math.random()*(i+1));
          [chunks[i],chunks[j]]=[chunks[j],chunks[i]];
        }
        displayBars.push(...chunks.flat());
      });
      for (let i=displayBars.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [displayBars[i],displayBars[j]]=[displayBars[j],displayBars[i]];
      }
      block2Seeds=[];
      const total=grid.cols*grid.rows;
      for (let i=0;i<total;i++) block2Seeds.push(Math.random());
    }

    function buildGrid(){
      const w=canvas.width;
      const h=canvas.height;
      const baseW=Math.floor(w*0.6*CONFIG.containerScale);
      const baseH=Math.floor(h*0.6*CONFIG.containerScale);
      const startX=Math.floor((w-baseW)/2);
      const startY=Math.floor((h-baseH)/2);

      const baseRatio=CONFIG.cellRatio*CONFIG.cellScale;
      const cellW=Math.max(2,Math.floor(baseW*baseRatio));
      const cellH=Math.max(2,Math.floor(baseH*baseRatio));

      const cols=Math.floor(baseW/cellW);
      const rows=Math.floor(baseH/cellH);

      if (displayBars.length===0) shuffleGroups();

      const cells=new Array(cols*rows);
      let barIdx=0;
      let currentBar=displayBars[0]||bars[0];
      let repeatLeft=Math.floor(Math.random()*124)+1;
      let step=0;

      for (let c=0;c<cols;c++){
        for (let r=0;r<rows;r++){
          if (repeatLeft<=0){
            barIdx++;
            currentBar=displayBars[barIdx%displayBars.length]||bars[0];
            repeatLeft=Math.floor(Math.random()*124)+1;
            step=0;
          }
          cells[c*rows+r]={barId:currentBar.id,repeatStep:step};
          repeatLeft--; step++;
        }
      }

      const rects=[];
      for (let c=0;c<cols;c++){
        let r=0;
        while(r<rows){
          const cell=cells[c*rows+r];
          const startR=r;
          r++;
          while(r<rows && cells[c*rows+r].barId===cell.barId && cells[c*rows+r].repeatStep===cells[c*rows+r-1].repeatStep+1){
            r++;
          }
          rects.push({
            x:startX+c*cellW,
            y:startY+startR*cellH,
            w:cellW,
            h:(r-startR)*cellH,
            barId:cell.barId,
            repeatStep:cells[c*rows+startR].repeatStep,
            strokeSeed:Math.random(),
            hideSeed:Math.random()
          });
        }
      }

      grid={cols,rows,cellW,cellH,startX,startY,contentW:baseW,contentH:baseH};
      drawRects=rects;

      block2Seeds=[];
      for (let i=0;i<cols*rows;i++) block2Seeds.push(Math.random());
    }

    function drawBackground(){
      const w=canvas.width, h=canvas.height;
      const cx=w/2, cy=h/2;
      const maxR=Math.min(w,h)/2*CONFIG.bgRadialScale;
      const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,maxR);
      grad.addColorStop(0,CONFIG.bgColorA);
      grad.addColorStop(1,CONFIG.bgColorB);
      ctx.fillStyle=grad;
      ctx.fillRect(0,0,w,h);
    }

    function drawGridUnder(){
      if (!CONFIG.showGrid) return;
      const {startX,startY,contentW,contentH}=grid;
      if (!contentW || !contentH) return;
      for (let y=startY+CONFIG.gridOffsetY; y<=startY+contentH+CONFIG.gridOffsetY; y+=CONFIG.gridStepY){
        let t=(y-(startY+CONFIG.gridOffsetY))/contentH;
        t = (t + CONFIG.gridColorOffset + gridColorPhase) % 1;
        ctx.strokeStyle=lerpColor(CONFIG.gridColorA,CONFIG.gridColorB,t);
        ctx.beginPath();
        ctx.moveTo(startX+CONFIG.gridOffsetX, y+0.5);
        ctx.lineTo(startX+contentW+CONFIG.gridOffsetX, y+0.5);
        ctx.stroke();
      }
      for (let x=startX+CONFIG.gridOffsetX; x<=startX+contentW+CONFIG.gridOffsetX; x+=CONFIG.gridStepX){
        let t=(x-(startX+CONFIG.gridOffsetX))/contentW;
        t = (t + CONFIG.gridColorOffset + gridColorPhase) % 1;
        ctx.strokeStyle=lerpColor(CONFIG.gridColorA,CONFIG.gridColorB,t);
        ctx.beginPath();
        ctx.moveTo(x+0.5, startY+CONFIG.gridOffsetY);
        ctx.lineTo(x+0.5, startY+contentH+CONFIG.gridOffsetY);
        ctx.stroke();
      }
    }

    function drawBlock1(){
      const {startY,contentH,cellH} = grid;
      const offsetPx = (CONFIG.blockOffsetRows % (grid.rows||1)) * cellH;
      for (let i=0;i<drawRects.length;i++){
        const rect=drawRects[i];
        if (rect.hideSeed*100 < CONFIG.hidePercentBlocks) continue;
        const bar=bars[rect.barId];
        if (bar.energy < CONFIG.silenceThreshold) continue;
        const color=bar.colorA;
        const w=rect.w*CONFIG.blockScale;
        const h=rect.h*CONFIG.blockScale;
        let y=rect.y + offsetPx;
        while (y + h > startY + contentH) y -= contentH;
        ctx.fillStyle=color;
        ctx.fillRect(rect.x, y, w, h);
        const strokeW = CONFIG.strokeWidth + rect.strokeSeed * CONFIG.strokeRandomMax;
        if (strokeW>0){
          ctx.lineWidth=strokeW;
          ctx.strokeStyle=color;
          ctx.strokeRect(rect.x, y, w, h);
        }
      }
    }

    function drawBlock2(){
      const {cols,rows,cellW,cellH,startX,startY} = grid;
      if (!cols || !rows) return;
      for (let c=0;c<cols;c++){
        for (let r=0;r<rows;r++){
          const idx=c*rows+r;
          const seed=block2Seeds[idx] || 0;
          if (seed > BLOCK2.density) continue;
          if (seed*100 < BLOCK2.hidePercent) continue;
          const barIdx=(idx + BLOCK2.offset) % bars.length;
          const bar=bars[barIdx];
          if (bar.energy < CONFIG.silenceThreshold) continue;
          const col = bar.colorB;
          const x = startX + c * cellW;
          const y = startY + r * cellH;
          const h = Math.max(1, Math.floor(cellH * 0.35 * BLOCK2.scale));
          const len = Math.floor(cellW * BLOCK2.lengthFactor * BLOCK2.scale);
          const yy = y + Math.floor(cellH/2 - h/2);
          ctx.fillStyle = col;
          ctx.fillRect(x, yy, len, h);
          const strokeW = BLOCK2.strokeWidth + Math.random() * BLOCK2.strokeRandom;
          if (strokeW>0){
            ctx.lineWidth=strokeW;
            ctx.strokeStyle=col;
            ctx.strokeRect(x, yy, len, h);
          }
        }
      }
    }

    function animate(timestamp=0){
      if (!isPlaying) return;
      requestAnimationFrame(animate);
      analyser.getByteFrequencyData(dataArray);

      const now=performance.now();
      const fps=1000/(now-lastFrameTime);
      document.getElementById('fps').textContent='fps: '+fps.toFixed(1);
      const dt = now - lastFrameTime;
      lastFrameTime=now;

      // ÑÐµÑ‚ÐºÐ° "Ð´Ñ‹ÑˆÐ¸Ñ‚" Ð¾Ñ‚ shuffle
      const speed = 1000 / CONFIG.shuffleInterval; // Ñ‡ÐµÐ¼ Ð¼ÐµÐ½ÑŒÑˆÐµ Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð», Ñ‚ÐµÐ¼ Ð±Ñ‹ÑÑ‚Ñ€ÐµÐµ
      gridColorPhase = (gridColorPhase + dt * 0.0002 * speed) % 1;

      bars.forEach(bar=>{
        const idx=spectrumIndex(bar.freqBin);
        bar.energy = (dataArray[idx] || 0) / 255;
        if (bar.energy < CONFIG.silenceThreshold) {
          bar.colorA = groups[bar.groupIndex] ? groups[bar.groupIndex].silenceColor : 'rgba(0,0,0,0)';
          bar.colorB = 'rgba(0,0,0,0)';
        } else {
          bar.colorA = getColorFromPaletteArr(currentBlockPalette, bar.energy);
          bar.colorB = getColorFromPaletteArr(currentStripePalette, bar.energy);
        }
      });

      if (timestamp - lastShuffleTime > CONFIG.shuffleInterval || displayBars.length===0){
        shuffleGroups();
        buildGrid();
        lastShuffleTime = timestamp;
      }

      drawBackground();
      drawGridUnder();
      drawBlock1();
      drawBlock2();

      specCtx.clearRect(0,0,specCanvas.width,specCanvas.height);
      for (let i=0;i<specCanvas.width && i<dataArray.length;i++){
        const idx=spectrumIndex(i);
        const v=dataArray[idx]/255;
        const h=Math.floor(v*(specCanvas.height-2));
        specCtx.fillStyle=`rgb(${Math.floor(v*255)},${Math.floor(v*255)},${Math.floor(v*255)})`;
        specCtx.fillRect(i, specCanvas.height-h, 1, h);
      }
    }
  </script>
</body>
</html>
