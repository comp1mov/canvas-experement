<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spectrum Under Construction v2</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
    }
    canvas { 
      display: block; 
      width: 100vw; 
      height: 100vh;
      background: #c8c8c8;
    }
    #controls {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0,0,0,0.9);
      padding: 20px;
      border-radius: 8px;
      color: white;
      text-align: center;
      border: 2px solid #ff006e;
      max-width: 400px;
    }
    button {
      background: linear-gradient(135deg, #ff006e, #8ac926);
      border: none;
      color: white;
      padding: 12px 24px;
      font-size: 13px;
      font-family: 'Courier New', monospace;
      margin: 5px;
      cursor: pointer;
      border-radius: 4px;
      transition: 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
    }
    button:hover { 
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(255, 0, 110, 0.5);
    }
    button:disabled { 
      background: #333;
      cursor: not-allowed;
      transform: scale(1);
      box-shadow: none;
    }
    #status {
      margin-top: 10px;
      font-size: 11px;
      color: #aaa;
    }
    .slider-group {
      margin: 10px 0;
      text-align: left;
    }
    .slider-group label {
      display: block;
      font-size: 10px;
      margin-bottom: 5px;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    input[type="range"] {
      width: 100%;
      margin: 5px 0;
    }
    h2 {
      font-size: 14px;
      margin-bottom: 10px;
      letter-spacing: 2px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="controls">
    <h2>üèóÔ∏è SPECTRUM v2</h2>
    <button id="micBtn">Start Microphone</button>
    <button id="fileBtn">Load Audio File</button>
    <input type="file" id="fileInput" accept="audio/*" style="display:none">
    
    <div class="slider-group">
      <label>Gain: <span id="gainValue">3.0x</span></label>
      <input type="range" id="gainSlider" min="0.5" max="10" step="0.5" value="3">
    </div>
    
    <div class="slider-group">
      <label>Bar Scale: <span id="sizeValue">0.5%</span></label>
      <input type="range" id="sizeSlider" min="0.2" max="2" step="0.1" value="0.5">
    </div>
    
    <div class="slider-group">
      <label>Shuffle Speed: <span id="shuffleValue">3.0s</span></label>
      <input type="range" id="shuffleSlider" min="1" max="10" step="0.5" value="3">
    </div>
    
    <div class="slider-group">
      <label>Silence: <span id="thresholdValue">0.05</span></label>
      <input type="range" id="thresholdSlider" min="0.01" max="0.2" step="0.01" value="0.05">
    </div>
    
    <div id="status">Click button to start</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let audioContext, analyser, gainNode, dataArray;
    let isPlaying = false;
    let audioSource = null;

    let CONFIG = {
      numBars: 1024,
      numGroups: 4,
      barsPerGroup: 256,
      
      barWidthRatio: 0.005,   // Bar width as % of screen width (adjustable)
      barHeightRatio: 0.005,  // Bar height as % of screen height (adjustable)
      
      padding: 0.19,      // 19% padding
      
      shuffleInterval: 3000,
      silenceThreshold: 0.05,
      gain: 3.0,
      
      attackSpeed: 0.8,
      decaySpeed: 0.3,
      
      // Group shuffle configs
      groupShuffleSizes: [60, 8, 4, 256], // Group A, B, C, D chunk sizes
      
      palettes: [
        {
          name: 'Black to Pink',
          colors: ['#000000', '#1a0010', '#330020', '#660040', '#cc0080', '#ff00a0', '#ff33b8', '#ff66cc']
        },
        {
          name: 'Transparent to Cyan',
          colors: ['rgba(0,0,0,0)', 'rgba(0,100,100,0.3)', 'rgba(0,150,150,0.5)', '#008888', '#00cccc', '#00ffff']
        },
        {
          name: 'Transparent to Green',
          colors: ['rgba(0,0,0,0)', 'rgba(20,40,0,0.3)', 'rgba(40,80,0,0.5)', '#558800', '#88cc00', '#aaff00', '#ccff33']
        },
        {
          name: 'Black to White',
          colors: ['#000000', '#1a1a1a', '#444444', '#00ff88', '#00ffff', '#88ffff', '#ffffff']
        }
      ]
    };

    let bars = [];
    let groups = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // UI Controls
    document.getElementById('gainSlider').addEventListener('input', (e) => {
      CONFIG.gain = parseFloat(e.target.value);
      if (gainNode) gainNode.gain.value = CONFIG.gain;
      document.getElementById('gainValue').textContent = CONFIG.gain.toFixed(1) + 'x';
    });

    document.getElementById('sizeSlider').addEventListener('input', (e) => {
      const scale = parseFloat(e.target.value) / 100; // Convert to ratio
      CONFIG.barWidthRatio = scale;
      CONFIG.barHeightRatio = scale;
      document.getElementById('sizeValue').textContent = e.target.value + '%';
    });

    document.getElementById('shuffleSlider').addEventListener('input', (e) => {
      CONFIG.shuffleInterval = parseFloat(e.target.value) * 1000;
      document.getElementById('shuffleValue').textContent = e.target.value + 's';
    });

    document.getElementById('thresholdSlider').addEventListener('input', (e) => {
      CONFIG.silenceThreshold = parseFloat(e.target.value);
      document.getElementById('thresholdValue').textContent = CONFIG.silenceThreshold.toFixed(2);
    });

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.65;
        
        gainNode = audioContext.createGain();
        gainNode.gain.value = CONFIG.gain;
        
        dataArray = new Uint8Array(1024);
      }
    }

    function initBars() {
      bars = [];
      groups = [];
      
      // Create 1024 bars
      for (let i = 0; i < CONFIG.numBars; i++) {
        bars.push({
          id: i,
          freqBin: i,
          energy: 0,
          color: 'rgba(0,0,0,0)',
          groupIndex: Math.floor(i / CONFIG.barsPerGroup)
        });
      }
      
      // Create 4 groups with different shuffle chunk sizes
      for (let g = 0; g < CONFIG.numGroups; g++) {
        const groupBars = bars.filter(b => b.groupIndex === g);
        const chunkSize = CONFIG.groupShuffleSizes[g];
        
        groups.push({
          index: g,
          palette: CONFIG.palettes[g],
          bars: groupBars,
          chunkSize: chunkSize
        });
      }
    }

    document.getElementById('micBtn').addEventListener('click', async () => {
      try {
        initAudio();
        initBars();
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioSource = audioContext.createMediaStreamSource(stream);
        audioSource.connect(gainNode);
        gainNode.connect(analyser);
        
        isPlaying = true;
        document.getElementById('micBtn').disabled = true;
        document.getElementById('fileBtn').disabled = true;
        document.getElementById('status').textContent = 'üé§ Microphone active';
        
        if (audioContext.state === 'suspended') audioContext.resume();
        animate();
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = '‚ùå Mic access denied';
      }
    });

    document.getElementById('fileBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        initAudio();
        initBars();
        
        const arrayBuffer = await file.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        if (audioSource && audioSource.stop) audioSource.stop();
        
        audioSource = audioContext.createBufferSource();
        audioSource.buffer = audioBuffer;
        audioSource.loop = true;
        audioSource.connect(gainNode);
        gainNode.connect(analyser);
        analyser.connect(audioContext.destination);
        audioSource.start(0);
        
        isPlaying = true;
        document.getElementById('micBtn').disabled = true;
        document.getElementById('fileBtn').disabled = true;
        document.getElementById('status').textContent = `üéµ ${file.name}`;
        
        if (audioContext.state === 'suspended') audioContext.resume();
        animate();
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = '‚ùå Could not load file';
      }
    });

    function hexToRgb(hex) {
      if (hex.startsWith('rgba')) {
        const match = hex.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
        if (match) {
          return {
            r: parseInt(match[1]),
            g: parseInt(match[2]),
            b: parseInt(match[3]),
            a: match[4] ? parseFloat(match[4]) : 1
          };
        }
      }
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: 1
      } : { r: 0, g: 0, b: 0, a: 1 };
    }

    function lerpColor(color1, color2, t) {
      const c1 = hexToRgb(color1);
      const c2 = hexToRgb(color2);
      
      const r = Math.round(c1.r + (c2.r - c1.r) * t);
      const g = Math.round(c1.g + (c2.g - c1.g) * t);
      const b = Math.round(c1.b + (c2.b - c1.b) * t);
      const a = c1.a + (c2.a - c1.a) * t;
      
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }

    function getColorFromPalette(palette, energy) {
      const colors = palette.colors;
      const numColors = colors.length;
      
      const colorIndex = energy * (numColors - 1);
      const lowerIndex = Math.floor(colorIndex);
      const upperIndex = Math.min(lowerIndex + 1, numColors - 1);
      const t = colorIndex - lowerIndex;
      
      return lerpColor(colors[lowerIndex], colors[upperIndex], t);
    }

    let lastShuffleTime = 0;
    let displayBars = []; // Final shuffled array for display
    
    function shuffleGroups() {
      displayBars = [];
      
      // Shuffle each group separately based on chunk size
      groups.forEach(group => {
        const groupBars = [...group.bars];
        const chunkSize = group.chunkSize;
        const numChunks = Math.floor(groupBars.length / chunkSize);
        
        // Split into chunks
        const chunks = [];
        for (let i = 0; i < numChunks; i++) {
          chunks.push(groupBars.slice(i * chunkSize, (i + 1) * chunkSize));
        }
        
        // Add remainder if any
        const remainder = groupBars.length % chunkSize;
        if (remainder > 0) {
          chunks.push(groupBars.slice(-remainder));
        }
        
        // Shuffle chunks
        for (let i = chunks.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [chunks[i], chunks[j]] = [chunks[j], chunks[i]];
        }
        
        // Flatten back and add to display
        displayBars.push(...chunks.flat());
      });
      
      // Final inter-group shuffle (mix all groups together)
      for (let i = displayBars.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [displayBars[i], displayBars[j]] = [displayBars[j], displayBars[i]];
      }
    }
    
    function animate(timestamp = 0) {
      if (!isPlaying) return;
      requestAnimationFrame(animate);

      analyser.getByteFrequencyData(dataArray);

      const w = canvas.width;
      const h = canvas.height;
      
      // Calculate bar dimensions based on screen proportions
      const barWidth = Math.floor(w * CONFIG.barWidthRatio);
      const barHeight = Math.floor(h * CONFIG.barHeightRatio);
      
      // Calculate content area with padding
      const paddingPx = Math.min(w, h) * CONFIG.padding;
      const contentWidth = w - 2 * paddingPx;
      const contentHeight = h - 2 * paddingPx;
      const startX = paddingPx;
      const startY = paddingPx;

      // Clear
      ctx.fillStyle = '#c8c8c8';
      ctx.fillRect(0, 0, w, h);

      // Update bar energies and colors
      bars.forEach(bar => {
        const rawEnergy = dataArray[bar.freqBin] / 255;
        
        // Attack/Decay
        if (rawEnergy > bar.energy) {
          bar.energy += (rawEnergy - bar.energy) * CONFIG.attackSpeed;
        } else {
          bar.energy += (rawEnergy - bar.energy) * CONFIG.decaySpeed;
        }
        
        // Get color based on energy
        const group = groups[bar.groupIndex];
        if (bar.energy < CONFIG.silenceThreshold) {
          bar.color = 'rgba(0,0,0,0)';
        } else {
          bar.color = getColorFromPalette(group.palette, bar.energy);
        }
      });

      // Shuffle periodically
      if (timestamp - lastShuffleTime > CONFIG.shuffleInterval || displayBars.length === 0) {
        shuffleGroups();
        lastShuffleTime = timestamp;
      }

      // Calculate grid dimensions
      const cols = Math.floor(contentWidth / barWidth);
      const rows = Math.floor(contentHeight / barHeight);

      // Draw grid: fill columns from top to bottom, then move right
      let barIndex = 0;
      for (let col = 0; col < cols; col++) {
        for (let row = 0; row < rows; row++) {
          // Get bar (with wrap-around duplication)
          const bar = displayBars[barIndex % displayBars.length];
          barIndex++;
          
          const x = startX + col * barWidth;
          const y = startY + row * barHeight;
          
          // Draw cell
          ctx.fillStyle = bar.color;
          ctx.fillRect(x, y, barWidth, barHeight);
        }
      }

      // Debug: draw content area border when quiet
      const avgEnergy = bars.reduce((sum, b) => sum + b.energy, 0) / bars.length;
      if (avgEnergy < 0.02) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.strokeRect(startX, startY, contentWidth, contentHeight);
      }
    }
  </script>
</body>
</html>
