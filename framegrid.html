<!DOCTYPE html>
<!--
╔════════════════════════════════════════════════════════════════╗
║      FRAMEGRID v0.12.4 FIXED -(2026)        ║
╚════════════════════════════════════════════════════════════════╝

✅ ИСПРАВЛЕНИЯ:

1. MP4 Export - Codec изменен на avc1.640028 (H.264 Level 4.0)
   Решает ошибку: "coded area exceeds the maximum coded area"
   Поддерживает до 2,073,600 пикселей (было 921,600)

2. Оптимизированы разрешения:
   - MP4 Grid: 120px/кадр, макс 1080px
   - MP4 Single: макс 720px
   - Файлы меньше в 3 раза, экспорт быстрее


⚠️  Требования: Chrome 94+, Edge 94+, Safari 16.4+
-->


<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <title>FRAMEGRID v0.10</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%; overflow: hidden; background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff; user-select: none; -webkit-user-select: none;
    }
    .app { width: 100%; height: 100%; display: flex; flex-direction: column; background: var(--bg-color, #0a0a0a); }

    /* METADATA BAR */
    .metadata-bar {
      height: 36px; min-height: 36px; background: #000;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      display: flex; align-items: center; padding: 0 12px; gap: 16px;
      font-size: 11px; letter-spacing: 0.04em; z-index: 10;
    }
    .metadata-bar.hidden { display: none; }
    .metadata-logo { font-weight: 700; color: #fff; display: flex; align-items: center; gap: 6px; }
    .metadata-logo::before { content: ''; width: 6px; height: 6px; background: #35f2a3; border-radius: 1px; }
    .metadata-item { color: rgba(255,255,255,0.6); }
    .metadata-item span { color: rgba(255,255,255,0.9); }
    .metadata-spacer { flex: 1; }
    .menu-toggle {
      width: 28px; height: 28px; background: transparent;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 2px;
      cursor: pointer; display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 3px;
    }
    .menu-toggle:hover { background: rgba(255,255,255,0.1); }
    .menu-toggle.active { background: rgba(53, 242, 163, 0.2); border-color: #35f2a3; }
    .menu-toggle span { width: 12px; height: 1px; background: rgba(255,255,255,0.8); }

    /* CANVAS AREA */
    .canvas-area { flex: 1; position: relative; overflow: hidden; cursor: crosshair; }
    .canvas-area.panning { cursor: move; }
    .canvas-area.has-menu { margin-right: 280px; }
    .canvas-inner { position: absolute; transform-origin: 0 0; }

    /* GRID */
    .frames-grid { display: grid; gap: var(--grid-gap, 2px); }
    .frame-item { background: #000; position: relative; }
    .frame-item.dimmed { opacity: 0.25; }
    .frame-image-wrap {
      position: relative; width: 100%;
      aspect-ratio: var(--video-aspect, 16/9);
      background: #111; overflow: hidden;
    }
    .frame-image-wrap img { width: 100%; height: 100%; object-fit: cover; display: block; }
    
    .frame-timecode {
      position: absolute; left: 0; right: 0;
      background: var(--tc-bg-color, rgba(0,0,0,0.7));
      padding: 4px 6px; font-size: var(--meta-font-size, 10px);
      color: var(--tc-text-color, #fff); font-variant-numeric: tabular-nums;
      text-align: var(--tc-align, left);
    }
    .frame-timecode.pos-top { top: 0; }
    .frame-timecode.pos-bottom { bottom: 0; }
    .frame-timecode.hidden { display: none; }

    /* INFO CARD */
    .info-card {
      background: #000; display: flex; flex-direction: column;
      padding: 8%; aspect-ratio: var(--video-aspect, 16/9);
      justify-content: center; border: 1px solid rgba(255,255,255,0.2);
    }
    .info-card-title { font-size: clamp(8px, 2.5vw, 18px); font-weight: 700; color: #35f2a3; margin-bottom: 0.6em; }
    .info-card-row { font-size: clamp(6px, 2vw, 14px); color: rgba(255,255,255,0.7); margin-bottom: 0.3em; }

    /* DROP ZONE */
    .drop-zone {
      position: absolute; inset: 0; display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 20px;
      background: var(--bg-color, #0a0a0a); z-index: 5;
    }
    .drop-zone.hidden { opacity: 0; pointer-events: none; }
    .drop-zone-icon {
      width: 80px; height: 80px; border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 4px; display: flex; align-items: center; justify-content: center;
      font-size: 32px; color: rgba(255,255,255,0.4);
    }
    .drop-zone-text { font-size: 14px; color: rgba(255,255,255,0.6); text-align: center; line-height: 1.6; }
    .drop-zone-formats { font-size: 10px; color: rgba(255,255,255,0.35); margin-top: 8px; }
    .drop-zone-btn {
      padding: 10px 24px; background: #35f2a3; color: #000; border: none;
      border-radius: 2px; font-size: 11px; font-weight: 600;
      letter-spacing: 0.08em; text-transform: uppercase; cursor: pointer;
    }
    .drop-zone-btn:hover { background: #4df7b5; }
    .drop-zone.drag-over { background: rgba(53, 242, 163, 0.1); }

    /* SIDE MENU */
    .side-menu {
      position: absolute; top: 0; right: 0; bottom: 0; width: 280px;
      background: rgba(0,0,0,0.98); border-left: 1px solid rgba(255,255,255,0.15);
      transform: translateX(100%); transition: transform 0.25s ease;
      z-index: 20; display: flex; flex-direction: column; overflow-y: auto;
    }
    .side-menu.open { transform: translateX(0); }
    .side-menu-header {
      padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,0.1);
      font-size: 10px; letter-spacing: 0.1em; text-transform: uppercase;
      color: rgba(255,255,255,0.5); display: flex; justify-content: space-between;
    }
    .menu-close-btn {
      width: 24px; height: 24px; background: transparent;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 2px;
      color: rgba(255,255,255,0.6); font-size: 14px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .menu-section { padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.08); }
    .menu-section.collapsed .menu-section-content { display: none; }
    .menu-section-title {
      font-size: 9px; letter-spacing: 0.1em; text-transform: uppercase;
      color: rgba(255,255,255,0.4); margin-bottom: 12px; cursor: pointer;
      display: flex; justify-content: space-between;
    }
    .menu-section-title::after { content: '−'; font-size: 14px; opacity: 0.5; }
    .menu-section.collapsed .menu-section-title::after { content: '+'; }
    .menu-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .menu-row:last-child { margin-bottom: 0; }
    .menu-label { font-size: 11px; color: rgba(255,255,255,0.75); }
    .menu-hint {
      font-size: 9px; color: rgba(53, 242, 163, 0.9); margin-top: 8px;
      padding: 8px; background: rgba(53, 242, 163, 0.1); border-radius: 2px; line-height: 1.4;
    }
    .menu-input {
      width: 70px; padding: 6px 8px; background: #111;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 2px;
      color: #fff; font-size: 11px; text-align: center;
    }
    .menu-input:focus { outline: none; border-color: #35f2a3; }
    .menu-input-group { display: flex; align-items: center; gap: 2px; }
    .menu-input-narrow { width: 44px; }
    .menu-input-btn {
      width: 28px; height: 28px; background: #222; border: 1px solid rgba(255,255,255,0.2);
      border-radius: 2px; color: #fff; font-size: 16px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .menu-input-btn:hover { background: #333; }
    .menu-input-btn:active { background: #35f2a3; color: #000; }

    /* Quick Toolbar */
    .quick-toolbar {
      position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; z-index: 15;
    }
    .quick-btn {
      width: 36px; height: 36px; background: rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.25); border-radius: 4px;
      color: rgba(255,255,255,0.8); font-size: 14px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .quick-btn:hover { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.4); }
    .quick-btn:active, .quick-btn.active { background: rgba(53,242,163,0.3); border-color: #35f2a3; color: #35f2a3; }
    .quick-btn svg { width: 18px; height: 18px; fill: currentColor; }
    @media (max-width: 768px) {
      .quick-toolbar { top: 44px; }
    }
    .menu-select {
      padding: 6px 8px; background: #111;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 2px;
      color: #fff; font-size: 11px; cursor: pointer;
    }
    .menu-toggle-switch {
      position: relative; width: 36px; height: 20px;
      background: #333; border-radius: 10px; cursor: pointer;
    }
    .menu-toggle-switch.active { background: #35f2a3; }
    .menu-toggle-switch::after {
      content: ''; position: absolute; top: 2px; left: 2px;
      width: 16px; height: 16px; background: #fff; border-radius: 50%;
      transition: transform 0.2s ease;
    }
    .menu-toggle-switch.active::after { transform: translateX(16px); }
    .menu-slider-row { display: flex; align-items: center; gap: 10px; }
    .menu-slider {
      flex: 1; height: 4px; -webkit-appearance: none; appearance: none;
      background: #333; border-radius: 2px; cursor: pointer;
    }
    .menu-slider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px;
      background: #35f2a3; border-radius: 50%; cursor: pointer;
    }
    .menu-slider-value { font-size: 10px; color: rgba(255,255,255,0.6); min-width: 36px; text-align: right; }
    .menu-btn {
      width: 100%; padding: 10px 16px; background: transparent;
      border: 1px solid rgba(255,255,255,0.25); border-radius: 2px;
      color: rgba(255,255,255,0.8); font-size: 10px; letter-spacing: 0.08em;
      text-transform: uppercase; cursor: pointer; margin-top: 8px;
    }
    .menu-btn:first-of-type { margin-top: 0; }
    .menu-btn:hover { background: rgba(255,255,255,0.1); }
    .menu-btn.primary { background: #35f2a3; border-color: #35f2a3; color: #000; }
    .menu-btn.primary:hover { background: #4df7b5; }
    .menu-color-input {
      width: 36px; height: 28px; padding: 2px; background: #111;
      border: 1px solid rgba(255,255,255,0.2); border-radius: 2px; cursor: pointer;
    }

    /* ABOUT */
    .about-section { padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); margin-top: auto; }
    .about-header { display: flex; justify-content: space-between; cursor: pointer; }
    .about-section.collapsed .about-content { display: none; }
    .about-title { font-size: 10px; letter-spacing: 0.12em; color: #35f2a3; }
    .about-toggle { font-size: 14px; color: rgba(255,255,255,0.4); }
    .about-section.collapsed .about-toggle::after { content: '+'; }
    .about-section:not(.collapsed) .about-toggle::after { content: '−'; }
    .about-content { margin-top: 12px; }
    .about-version { font-size: 9px; color: rgba(255,255,255,0.4); margin-bottom: 8px; }
    .about-description { font-size: 10px; line-height: 1.5; color: rgba(255,255,255,0.6); margin-bottom: 12px; }
    .about-copyright { font-size: 9px; color: rgba(255,255,255,0.3); margin-top: 12px; text-align: center; }
    .about-author { color: #35f2a3; text-decoration: none; }
    .about-author:hover { text-decoration: underline; }
    .about-subtitle { font-size: 9px; color: rgba(255,255,255,0.5); margin: 12px 0 8px; text-transform: uppercase; letter-spacing: 0.1em; }
    .about-hotkeys { margin-top: 8px; }
    .hotkey-row { font-size: 10px; color: rgba(255,255,255,0.5); margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
    .hotkey { 
      background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px; 
      font-family: monospace; font-size: 9px; color: rgba(255,255,255,0.7);
      min-width: 32px; text-align: center;
    }

    /* Animation preview overlay */
    .anim-overlay {
      position: absolute; inset: 0; background: rgba(0,0,0,0.95);
      display: none; align-items: center; justify-content: center;
      flex-direction: column; z-index: 100;
    }
    .anim-overlay.visible { display: flex; }
    .anim-frame { max-width: 90%; max-height: 80%; object-fit: contain; }
    .anim-info { 
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); padding: 8px 16px; border-radius: 4px;
      font-size: 12px; color: rgba(255,255,255,0.8);
    }
    .anim-close {
      position: absolute; top: 20px; right: 20px;
      width: 40px; height: 40px; background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
      color: #fff; font-size: 20px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .anim-close:hover { background: rgba(255,255,255,0.2); }

    /* PROGRESS */
    .progress-bar { position: absolute; bottom: 0; left: 0; right: 0; height: 3px; background: rgba(255,255,255,0.1); z-index: 30; display: none; }
    .progress-bar.visible { display: block; }
    .progress-fill { height: 100%; background: #35f2a3; width: 0%; }

    /* LOADING */
    .loading-overlay {
      position: absolute; inset: 0; background: rgba(0,0,0,0.8);
      display: none; flex-direction: column; align-items: center;
      justify-content: center; gap: 12px; z-index: 50;
    }
    .loading-overlay.visible { display: flex; }
    .loading-text { font-size: 12px; color: rgba(255,255,255,0.7); }
    .loading-progress { font-size: 11px; color: rgba(255,255,255,0.5); }

    @media (max-width: 768px) {
      .side-menu { width: 100%; }
      .canvas-area.has-menu { margin-right: 0; }
      .metadata-item.hide-mobile { display: none; }
    }
    #videoElement, #fileInput { display: none; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="metadata-bar" id="metadataBar">
      <div class="metadata-logo">FRAMEGRID v0.10</div>
      <div class="metadata-item" id="metaFilename">No file</div>
      <div class="metadata-item hide-mobile" id="metaResolution"></div>
      <div class="metadata-item" id="metaDuration"></div>
      <div class="metadata-item hide-mobile" id="metaDate"></div>
      <div class="metadata-item" id="metaFrames"></div>
      <div class="metadata-spacer"></div>
      <button class="menu-toggle" id="menuToggleBtn"><span></span><span></span><span></span></button>
    </div>

    <div class="canvas-area" id="canvasArea">
      <div class="canvas-inner" id="canvasInner">
        <div class="frames-grid" id="framesGrid"></div>
      </div>
      
      <!-- Quick Toolbar -->
      <div class="quick-toolbar" id="quickToolbar">
        <button class="quick-btn" id="qMode" title="View Mode (G/1)" style="font-size:10px;width:auto;padding:0 10px;">GRID</button>
        <button class="quick-btn" id="qPlay" title="Play/Stop (Space)">▶</button>
        <button class="quick-btn" id="qFit" title="Fit to Screen (F)">⊡</button>
        <button class="quick-btn" id="qRegen" title="Regenerate">↻</button>
        <button class="quick-btn" id="qExport" title="Export JPEG 2K">↓</button>
        <button class="quick-btn" id="qMenu" title="Menu (M)">☰</button>
      </div>
      
      <div class="drop-zone" id="dropZone">
        <div class="drop-zone-icon">▶</div>
        <div class="drop-zone-text">
          Drop video file here<br>
          <span style="font-size:11px;opacity:0.6;">or click to browse</span>
        </div>
        <button class="drop-zone-btn" id="browseBtn">SELECT VIDEO</button>
        <div class="drop-zone-formats">Supported: MP4, MOV, WebM, AVI, MKV, OGV, M4V</div>
        <div style="display:flex;gap:16px;margin-top:16px;flex-wrap:wrap;justify-content:center;">
          <div style="display:flex;align-items:center;gap:6px;font-size:10px;color:rgba(255,255,255,0.4);"><kbd style="background:rgba(255,255,255,0.1);padding:3px 8px;border-radius:3px;font-family:monospace;color:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.15);">Space</kbd> Play</div>
          <div style="display:flex;align-items:center;gap:6px;font-size:10px;color:rgba(255,255,255,0.4);"><kbd style="background:rgba(255,255,255,0.1);padding:3px 8px;border-radius:3px;font-family:monospace;color:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.15);">F</kbd> Fit</div>
          <div style="display:flex;align-items:center;gap:6px;font-size:10px;color:rgba(255,255,255,0.4);"><kbd style="background:rgba(255,255,255,0.1);padding:3px 8px;border-radius:3px;font-family:monospace;color:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.15);">M</kbd> Menu</div>
          <div style="display:flex;align-items:center;gap:6px;font-size:10px;color:rgba(255,255,255,0.4);"><kbd style="background:rgba(255,255,255,0.1);padding:3px 8px;border-radius:3px;font-family:monospace;color:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.15);">Esc</kbd> Close</div>
        </div>
      </div>
    </div>

    <div class="side-menu" id="sideMenu">
      <div class="side-menu-header">
        <span>Settings</span>
        <button class="menu-close-btn" id="menuCloseBtn">✕</button>
      </div>

      <div class="menu-section">
        <div class="menu-section-title">Frame Selection</div>
        <div class="menu-section-content">
          <div class="menu-row">
            <span class="menu-label">Mode</span>
            <select class="menu-select" id="selectionMode">
              <option value="count" selected>Fixed Count</option>
              <option value="seconds">Every N Sec</option>
              <option value="frames">Every N Frames</option>
            </select>
          </div>
          <div class="menu-row" id="countRow">
            <span class="menu-label">Frame Count</span>
            <div class="menu-input-group">
              <button class="menu-input-btn" id="countMinus">−</button>
              <input type="number" class="menu-input menu-input-narrow" id="frameCount" value="24" min="1" max="1000">
              <button class="menu-input-btn" id="countPlus">+</button>
            </div>
          </div>
          <div class="menu-row" id="intervalRow" style="display:none;">
            <span class="menu-label" id="intervalLabel">Seconds</span>
            <input type="number" class="menu-input" id="intervalValue" value="3" min="1">
          </div>
          <div class="menu-row">
            <span class="menu-label">Start Frame</span>
            <div class="menu-input-group">
              <button class="menu-input-btn" id="startMinus">−</button>
              <input type="number" class="menu-input menu-input-narrow" id="startFrame" value="0" min="0" inputmode="decimal">
              <button class="menu-input-btn" id="startPlus">+</button>
            </div>
          </div>
          <div class="menu-row">
            <span class="menu-label">End Frame</span>
            <div class="menu-input-group">
              <button class="menu-input-btn" id="endMinus">−</button>
              <input type="number" class="menu-input menu-input-narrow" id="endFrame" value="0" min="0" inputmode="decimal">
              <button class="menu-input-btn" id="endPlus">+</button>
            </div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Quality</span>
            <select class="menu-select" id="qualitySelect">
              <option value="1">Full</option>
              <option value="0.5" selected>Half</option>
              <option value="0.25">Quarter</option>
            </select>
          </div>
          <button class="menu-btn primary" id="generateBtn">Regenerate Grid</button>
        </div>
      </div>

      <div class="menu-section">
        <div class="menu-section-title">Grid Layout</div>
        <div class="menu-section-content">
          <div class="menu-row">
            <span class="menu-label">Target Aspect</span>
            <select class="menu-select" id="canvasAspect">
              <option value="auto">Auto</option>
              <option value="1:1">1:1 Square</option>
              <option value="16:9">16:9 Wide</option>
              <option value="9:16">9:16 Vertical</option>
              <option value="4:3">4:3</option>
            </select>
          </div>
          <div class="menu-row">
            <span class="menu-label">Columns</span>
            <div class="menu-input-group">
              <button class="menu-input-btn" id="colsMinus">−</button>
              <input type="number" class="menu-input menu-input-narrow" id="gridCols" value="6" min="1" max="50">
              <button class="menu-input-btn" id="colsPlus">+</button>
            </div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Auto-fit</span>
            <div class="menu-toggle-switch active" id="toggleAutoFit"></div>
          </div>
          <div class="menu-hint" id="gridHint">Load video to see suggestions</div>
          <div class="menu-row">
            <span class="menu-label">Spacing</span>
            <div class="menu-slider-row">
              <input type="range" class="menu-slider" id="spacingSlider" min="0" max="20" value="2">
              <span class="menu-slider-value" id="spacingValue">2px</span>
            </div>
          </div>
        </div>
      </div>

      <div class="menu-section collapsed">
        <div class="menu-section-title">Display & Style</div>
        <div class="menu-section-content">
          <div class="menu-row">
            <span class="menu-label">Metadata Bar</span>
            <div class="menu-toggle-switch active" id="toggleMetadata"></div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Timecode</span>
            <div class="menu-toggle-switch" id="toggleTimecode"></div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Info Card</span>
            <div class="menu-toggle-switch" id="toggleInfoCard"></div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Font Size</span>
            <div class="menu-slider-row">
              <input type="range" class="menu-slider" id="fontSizeSlider" min="6" max="32" value="10">
              <span class="menu-slider-value" id="fontSizeValue">10px</span>
            </div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Background</span>
            <input type="color" class="menu-color-input" id="bgColor" value="#0a0a0a">
          </div>
          <div class="menu-row">
            <span class="menu-label">TC Text</span>
            <input type="color" class="menu-color-input" id="tcTextColor" value="#ffffff">
          </div>
          <div class="menu-row">
            <span class="menu-label">TC BG</span>
            <input type="color" class="menu-color-input" id="tcBgColor" value="#000000">
          </div>
          <div class="menu-row">
            <span class="menu-label">TC Opacity</span>
            <div class="menu-slider-row">
              <input type="range" class="menu-slider" id="tcOpacitySlider" min="0" max="100" value="70">
              <span class="menu-slider-value" id="tcOpacityValue">70%</span>
            </div>
          </div>
          <div class="menu-row">
            <span class="menu-label">TC Align</span>
            <select class="menu-select" id="tcAlign">
              <option value="left" selected>Left</option>
              <option value="center">Center</option>
              <option value="right">Right</option>
            </select>
          </div>
          <div class="menu-row">
            <span class="menu-label">TC Position</span>
            <select class="menu-select" id="tcPosition">
              <option value="top" selected>Top</option>
              <option value="bottom">Bottom</option>
            </select>
          </div>
        </div>
      </div>

      <div class="menu-section collapsed">
        <div class="menu-section-title">Animation Preview</div>
        <div class="menu-section-content">
          <div class="menu-row">
            <span class="menu-label">FPS</span>
            <div class="menu-input-group">
              <button class="menu-input-btn" id="fpsMinus">−</button>
              <input type="number" class="menu-input menu-input-narrow" id="animFps" value="8" min="1" max="30" inputmode="decimal">
              <button class="menu-input-btn" id="fpsPlus">+</button>
            </div>
          </div>
          <div class="menu-row">
            <span class="menu-label">Direction</span>
            <select class="menu-select" id="animDirection">
              <option value="forward">Forward</option>
              <option value="backward">Backward</option>
              <option value="pingpong">Ping-pong</option>
            </select>
          </div>
          <div class="menu-row">
            <span class="menu-label">Pattern</span>
            <select class="menu-select" id="animPattern">
              <option value="sequential">Sequential</option>
              <option value="center">Center-out</option>
              <option value="snake">Snake</option>
              <option value="vertical">Vertical</option>
            </select>
          </div>
          <button class="menu-btn primary" id="playBtn">▶ Play Animation</button>
          <button class="menu-btn" id="stopBtn" style="display:none;">■ Stop</button>
        </div>
      </div>

      <div class="menu-section collapsed">
        <div class="menu-section-title">Export</div>
        <div class="menu-section-content">
          <button class="menu-btn" id="exportSmallBtn">Export JPEG 2K</button>
          <button class="menu-btn" id="exportFullBtn">Export PNG Full</button>
          <button class="menu-btn" id="exportMp4GridBtn">Export MP4 Grid</button>
          <button class="menu-btn" id="exportMp4SingleBtn">Export MP4 Single</button>
          <button class="menu-btn" id="newVideoBtn">Load New Video</button>
        </div>
      </div>

      <div class="about-section collapsed">
        <div class="about-header" id="aboutHeader">
          <div class="about-title">FRAMEGRID</div>
          <div class="about-toggle"></div>
        </div>
        <div class="about-content">
          <div class="about-version">Version 0.08</div>
          <div class="about-description">Video frame extraction tool for contact sheets, storyboards, and AI analysis.</div>
          
          <div class="about-hotkeys">
            <div class="about-subtitle">Keyboard Shortcuts</div>
            <div class="hotkey-row"><span class="hotkey">Space</span> Play / Stop</div>
            <div class="hotkey-row"><span class="hotkey">F</span> Fit to Screen</div>
            <div class="hotkey-row"><span class="hotkey">M</span> Toggle Menu</div>
            <div class="hotkey-row"><span class="hotkey">Esc</span> Close / Stop</div>
          </div>
          
          <div class="about-copyright">
            © 2025 <a href="https://grisha-tsvetkov.com" target="_blank" class="about-author">Grisha Tsvetkov</a>
          </div>
        </div>
      </div>
    </div>

    <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-text">Processing frames...</div>
      <div class="loading-progress" id="loadingProgress">0 / 0</div>
    </div>
  </div>

  <video id="videoElement" crossorigin="anonymous"></video>
  <input type="file" id="fileInput" accept="video/*,.mov,.mp4,.webm,.avi,.mkv,.ogv,.m4v">
  <canvas id="captureCanvas" style="display:none;"></canvas>

  <script>
(function() {
  'use strict';

  const state = {
    videoFile: null, videoUrl: null, videoDuration: 0,
    videoWidth: 0, videoHeight: 0, videoFps: 30, videoDate: null,
    frames: [], frameCount: 24, gridCols: 6,
    selectionMode: 'count', intervalValue: 3, quality: 0.5,
    startFrame: 0, endFrame: 0, // Frame range
    showMetadata: true, showTimecode: false, showInfoCard: false,
    autoFit: true, canvasAspect: 'auto', bgColor: '#0a0a0a',
    fontSize: 10, spacing: 2,
    tcTextColor: '#ffffff', tcBgColor: '#000000', tcOpacity: 0.7,
    tcAlign: 'left', tcPosition: 'top',
    scale: 1, panX: 0, panY: 0, isPanning: false,
    startPanX: 0, startPanY: 0, startMouseX: 0, startMouseY: 0,
    menuOpen: false,
    // Animation
    animFps: 8, animDirection: 'forward', animPattern: 'sequential',
    isPlaying: false, animFrame: 0, animInterval: null,
    viewMode: 'grid' // 'grid' or 'single'
  };

  // DOM
  const $ = id => document.getElementById(id);
  const app = $('app'), metadataBar = $('metadataBar'), canvasArea = $('canvasArea');
  const canvasInner = $('canvasInner'), framesGrid = $('framesGrid'), dropZone = $('dropZone');
  const sideMenu = $('sideMenu'), menuToggleBtn = $('menuToggleBtn'), menuCloseBtn = $('menuCloseBtn');
  const progressBar = $('progressBar'), progressFill = $('progressFill');
  const loadingOverlay = $('loadingOverlay'), loadingProgress = $('loadingProgress');
  const videoElement = $('videoElement'), fileInput = $('fileInput');
  const captureCanvas = $('captureCanvas'), captureCtx = captureCanvas.getContext('2d');
  const gridHint = $('gridHint');

  const gridColsInput = $('gridCols'), canvasAspectSelect = $('canvasAspect');
  const selectionModeSelect = $('selectionMode'), frameCountInput = $('frameCount');
  const countMinus = $('countMinus'), countPlus = $('countPlus');
  const intervalValueInput = $('intervalValue'), qualitySelect = $('qualitySelect');
  const startFrameInput = $('startFrame'), endFrameInput = $('endFrame');
  const countRow = $('countRow'), intervalRow = $('intervalRow'), intervalLabel = $('intervalLabel');
  const toggleMetadata = $('toggleMetadata'), toggleTimecode = $('toggleTimecode');
  const toggleInfoCard = $('toggleInfoCard'), toggleAutoFit = $('toggleAutoFit');
  const fontSizeSlider = $('fontSizeSlider'), fontSizeValue = $('fontSizeValue');
  const spacingSlider = $('spacingSlider'), spacingValue = $('spacingValue');
  const bgColorInput = $('bgColor'), generateBtn = $('generateBtn');
  const exportSmallBtn = $('exportSmallBtn');
  const exportFullBtn = $('exportFullBtn');
  const exportGifGridBtn = $('exportGifGridBtn'), exportGifSingleBtn = $('exportGifSingleBtn');
  const exportMp4GridBtn = $('exportMp4GridBtn'), exportMp4SingleBtn = $('exportMp4SingleBtn');
  const newVideoBtn = $('newVideoBtn'), browseBtn = $('browseBtn');
  const metaFilename = $('metaFilename'), metaResolution = $('metaResolution');
  const metaDuration = $('metaDuration'), metaDate = $('metaDate'), metaFrames = $('metaFrames');
  
  // Animation controls
  const animFpsInput = $('animFps');
  const fpsMinus = $('fpsMinus'), fpsPlus = $('fpsPlus');
  const startMinus = $('startMinus'), startPlus = $('startPlus');
  const endMinus = $('endMinus'), endPlus = $('endPlus');
  const animDirectionSelect = $('animDirection'), animPatternSelect = $('animPattern');
  const playBtn = $('playBtn'), stopBtn = $('stopBtn');
  
  // Column +/- buttons
  const colsMinus = $('colsMinus'), colsPlus = $('colsPlus');
  
  // Quick toolbar
  const qMode = $('qMode'), qPlay = $('qPlay'), qFit = $('qFit'), qRegen = $('qRegen');
  const qExport = $('qExport'), qMenu = $('qMenu');
  
  // Timecode style controls
  const tcTextColorInput = $('tcTextColor'), tcBgColorInput = $('tcBgColor');
  const tcOpacitySlider = $('tcOpacitySlider'), tcOpacityValue = $('tcOpacityValue');
  const tcAlignSelect = $('tcAlign'), tcPositionSelect = $('tcPosition');

  // MENU
  function openMenu() {
    state.menuOpen = true;
    sideMenu.classList.add('open');
    menuToggleBtn.classList.add('active');
    if (window.innerWidth > 768) {
      canvasArea.classList.add('has-menu');
      if (state.autoFit && state.frames.length) setTimeout(fitToScreen, 260);
    }
  }
  function closeMenu() {
    state.menuOpen = false;
    sideMenu.classList.remove('open');
    menuToggleBtn.classList.remove('active');
    canvasArea.classList.remove('has-menu');
    if (state.autoFit && state.frames.length) setTimeout(fitToScreen, 260);
  }
  function toggleMenu() { state.menuOpen ? closeMenu() : openMenu(); }

  menuToggleBtn.onclick = toggleMenu;
  menuCloseBtn.onclick = closeMenu;
  $('aboutHeader').onclick = () => $('aboutHeader').parentElement.classList.toggle('collapsed');
  document.querySelectorAll('.menu-section-title').forEach(t => t.onclick = () => t.parentElement.classList.toggle('collapsed'));

  // FILE - Extended format support
  const supportedFormats = ['video/mp4', 'video/quicktime', 'video/webm', 'video/x-msvideo', 'video/x-matroska', 'video/ogg', 'video/x-m4v'];
  
  function handleFile(file) {
    if (!file) return;
    // Check by extension if MIME type not recognized
    const ext = file.name.split('.').pop().toLowerCase();
    const validExts = ['mp4', 'mov', 'webm', 'avi', 'mkv', 'ogv', 'm4v'];
    if (!file.type.startsWith('video/') && !validExts.includes(ext)) {
      return alert('Unsupported format. Please use: MP4, MOV, WebM, AVI, MKV, OGV, M4V');
    }
    
    state.videoFile = file;
    state.videoDate = new Date(file.lastModified);
    if (state.videoUrl) URL.revokeObjectURL(state.videoUrl);
    state.videoUrl = URL.createObjectURL(file);
    videoElement.src = state.videoUrl;
    videoElement.load();
    dropZone.classList.add('hidden');
    loadingOverlay.classList.add('visible');
  }

  videoElement.onloadedmetadata = () => {
    state.videoDuration = videoElement.duration;
    state.videoWidth = videoElement.videoWidth;
    state.videoHeight = videoElement.videoHeight;
    // Set frame range
    state.startFrame = 0;
    state.endFrame = Math.floor(state.videoDuration * state.videoFps);
    startFrameInput.value = state.startFrame;
    endFrameInput.value = state.endFrame;
    
    framesGrid.style.setProperty('--video-aspect', state.videoWidth / state.videoHeight);
    updateMetaDisplay();
    loadingOverlay.classList.remove('visible');
    generateFrames();
  };
  
  videoElement.onerror = () => {
    loadingOverlay.classList.remove('visible');
    dropZone.classList.remove('hidden');
    alert('Error loading video. This format may not be supported by your browser.\n\nTry converting to MP4 or WebM.');
  };

  function updateMetaDisplay() {
    metaFilename.innerHTML = `<span>${state.videoFile.name}</span>`;
    metaResolution.innerHTML = `<span>${state.videoWidth}×${state.videoHeight}</span>`;
    metaDuration.innerHTML = `<span>${formatTime(state.videoDuration)}</span>`;
    if (state.videoDate) metaDate.innerHTML = `<span>${formatDate(state.videoDate)}</span>`;
  }

  // Drag & Drop
  dropZone.ondragover = e => { e.preventDefault(); dropZone.classList.add('drag-over'); };
  dropZone.ondragleave = () => dropZone.classList.remove('drag-over');
  dropZone.ondrop = e => { e.preventDefault(); dropZone.classList.remove('drag-over'); handleFile(e.dataTransfer.files[0]); };
  dropZone.onclick = e => { if (!e.target.closest('.drop-zone-btn')) fileInput.click(); };
  browseBtn.onclick = () => fileInput.click();
  newVideoBtn.onclick = () => fileInput.click();
  fileInput.onchange = e => { if (e.target.files[0]) handleFile(e.target.files[0]); };

  // FRAMES
  async function generateFrames() {
    if (!state.videoUrl) return;
    const times = calculateFrameTimes();
    
    if (state.autoFit) {
      state.gridCols = calculateOptimalColumns(times.length);
      gridColsInput.value = state.gridCols;
    }
    
    state.frames = [];
    progressBar.classList.add('visible');
    loadingOverlay.classList.add('visible');
    captureCanvas.width = Math.round(state.videoWidth * state.quality);
    captureCanvas.height = Math.round(state.videoHeight * state.quality);

    for (let i = 0; i < times.length; i++) {
      const time = times[i];
      const dataUrl = await captureFrame(time);
      state.frames.push({ time, frameNumber: Math.floor(time * state.videoFps), dataUrl });
      progressFill.style.width = `${((i + 1) / times.length) * 100}%`;
      loadingProgress.textContent = `${i + 1} / ${times.length}`;
    }

    progressBar.classList.remove('visible');
    loadingOverlay.classList.remove('visible');
    progressFill.style.width = '0%';
    
    metaFrames.innerHTML = `<span>${state.frames.length}f</span>`;
    renderGrid();
    updateGridHint();
    if (state.autoFit) fitToScreen();
  }

  function calculateFrameTimes() {
    const times = [], max = 1000;
    const startTime = state.startFrame / state.videoFps;
    const endTime = state.endFrame / state.videoFps;
    const rangeDuration = endTime - startTime;
    
    if (state.selectionMode === 'count') {
      const n = Math.min(state.frameCount, max);
      for (let i = 0; i < n; i++) {
        const t = startTime + (rangeDuration / (n + 1)) * (i + 1);
        times.push(Math.min(t, endTime - 0.01));
      }
    } else if (state.selectionMode === 'seconds') {
      for (let t = startTime; t < endTime && times.length < max; t += state.intervalValue) {
        times.push(Math.min(t, endTime - 0.01));
      }
    } else {
      // Every N frames within range
      for (let f = state.startFrame; f < state.endFrame && times.length < max; f += state.intervalValue) {
        times.push(Math.min(f / state.videoFps, endTime - 0.01));
      }
    }
    return times;
  }

  function calculateOptimalColumns(totalFrames) {
    const frameAspect = state.videoWidth / state.videoHeight || 16/9;
    let targetCanvasAspect;
    
    if (state.canvasAspect !== 'auto') {
      const [w, h] = state.canvasAspect.split(':').map(Number);
      targetCanvasAspect = w / h;
    } else {
      const rect = canvasArea.getBoundingClientRect();
      targetCanvasAspect = rect.width / rect.height;
    }
    
    let bestCols = 4, bestScore = -Infinity;
    
    for (let cols = 1; cols <= Math.min(totalFrames, 40); cols++) {
      const rows = Math.ceil(totalFrames / cols);
      const gridAspect = (cols * frameAspect) / rows;
      const emptyFrames = cols * rows - totalFrames;
      
      const aspectRatio = gridAspect / targetCanvasAspect;
      const aspectScore = 1 - Math.abs(1 - aspectRatio) * 0.5;
      const emptyPenalty = (emptyFrames / totalFrames) * 0.3;
      const perfectBonus = emptyFrames === 0 ? 0.2 : 0;
      
      const score = aspectScore - emptyPenalty + perfectBonus;
      
      if (score > bestScore) {
        bestScore = score;
        bestCols = cols;
      }
    }
    return bestCols;
  }

  function updateGridHint() {
    const frameAspect = state.videoWidth / state.videoHeight || 16/9;
    
    // Calculate perfect frame counts for current/target aspect
    let targetAspect;
    if (state.canvasAspect !== 'auto') {
      const [w, h] = state.canvasAspect.split(':').map(Number);
      targetAspect = w / h;
    } else {
      const rect = canvasArea.getBoundingClientRect();
      targetAspect = rect.width / rect.height;
    }
    
    // Find perfect grid sizes (no empty cells, close to target aspect)
    const perfectCounts = [];
    for (let cols = 2; cols <= 12; cols++) {
      for (let rows = 2; rows <= 12; rows++) {
        const count = cols * rows;
        const gridAspect = (cols * frameAspect) / rows;
        const aspectDiff = Math.abs(gridAspect / targetAspect - 1);
        if (aspectDiff < 0.15 && count >= 4 && count <= 100) {
          perfectCounts.push({ count, cols, rows, diff: aspectDiff });
        }
      }
    }
    perfectCounts.sort((a, b) => a.diff - b.diff);
    const uniqueCounts = [...new Set(perfectCounts.slice(0, 6).map(p => p.count))];
    
    const n = state.frames.length || state.frameCount;
    if (!n) { 
      gridHint.innerHTML = uniqueCounts.length ? `Perfect frames: ${uniqueCounts.join(', ')}` : 'Load video to see suggestions';
      return; 
    }
    
    const rows = Math.ceil(n / state.gridCols);
    const gridAspect = (state.gridCols * frameAspect) / rows;
    const empty = state.gridCols * rows - n;
    
    const divisors = [];
    for (let i = 2; i <= Math.min(n, 20); i++) if (n % i === 0) divisors.push(i);
    
    let aspectLabel = '';
    if (Math.abs(gridAspect - 1) < 0.15) aspectLabel = '~1:1';
    else if (Math.abs(gridAspect - 16/9) < 0.2) aspectLabel = '~16:9';
    else if (Math.abs(gridAspect - 9/16) < 0.15) aspectLabel = '~9:16';
    else if (Math.abs(gridAspect - 4/3) < 0.15) aspectLabel = '~4:3';
    else aspectLabel = `~${gridAspect.toFixed(1)}:1`;
    
    let html = empty === 0 
      ? `✓ ${state.gridCols}×${rows} = ${n}f (${aspectLabel})`
      : `${state.gridCols}×${rows} (${empty} empty) ${aspectLabel}`;
    
    if (state.canvasAspect !== 'auto') html += `<br>Target: ${state.canvasAspect}`;
    if (divisors.length && empty > 0) html += `<br>Perfect cols: ${divisors.slice(0,5).join(', ')}`;
    if (uniqueCounts.length) html += `<br>Ideal frames: ${uniqueCounts.slice(0, 4).join(', ')}`;
    
    gridHint.innerHTML = html;
  }

  function captureFrame(time) {
    return new Promise(resolve => {
      videoElement.currentTime = time;
      videoElement.onseeked = () => {
        captureCtx.drawImage(videoElement, 0, 0, captureCanvas.width, captureCanvas.height);
        resolve(captureCanvas.toDataURL('image/jpeg', 0.9));
      };
    });
  }

  function updateTimecodeStyles() {
    const r = parseInt(state.tcBgColor.slice(1,3), 16);
    const g = parseInt(state.tcBgColor.slice(3,5), 16);
    const b = parseInt(state.tcBgColor.slice(5,7), 16);
    framesGrid.style.setProperty('--tc-bg-color', `rgba(${r},${g},${b},${state.tcOpacity})`);
    framesGrid.style.setProperty('--tc-text-color', state.tcTextColor);
    framesGrid.style.setProperty('--tc-align', state.tcAlign);
  }

  function renderGrid() {
    framesGrid.innerHTML = '';
    framesGrid.style.gridTemplateColumns = `repeat(${state.gridCols}, 1fr)`;
    framesGrid.style.setProperty('--grid-gap', `${state.spacing}px`);
    framesGrid.style.setProperty('--meta-font-size', `${state.fontSize}px`);
    updateTimecodeStyles();

    if (state.showInfoCard && state.videoFile) {
      const item = document.createElement('div');
      item.className = 'frame-item';
      item.innerHTML = `<div class="info-card">
        <div class="info-card-title">VIDEO INFO</div>
        <div class="info-card-row">File: ${state.videoFile.name}</div>
        <div class="info-card-row">Res: ${state.videoWidth}×${state.videoHeight}</div>
        <div class="info-card-row">Duration: ${formatTime(state.videoDuration)}</div>
        <div class="info-card-row">Frames: ${state.frames.length}</div>
      </div>`;
      framesGrid.appendChild(item);
    }

    state.frames.forEach(frame => {
      const item = document.createElement('div');
      item.className = 'frame-item';
      const wrap = document.createElement('div');
      wrap.className = 'frame-image-wrap';
      const img = document.createElement('img');
      img.src = frame.dataUrl;
      wrap.appendChild(img);
      const tc = document.createElement('div');
      tc.className = `frame-timecode pos-${state.tcPosition}` + (state.showTimecode ? '' : ' hidden');
      tc.textContent = `${formatTime(frame.time)} / F${frame.frameNumber}`;
      wrap.appendChild(tc);
      item.appendChild(wrap);
      framesGrid.appendChild(item);
    });
  }

  // PAN & ZOOM
  canvasArea.onwheel = e => {
    if (e.target.closest('.side-menu')) return;
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    const rect = canvasArea.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const newScale = Math.max(0.1, Math.min(10, state.scale * delta));
    const sc = newScale / state.scale;
    state.panX = mx - (mx - state.panX) * sc;
    state.panY = my - (my - state.panY) * sc;
    state.scale = newScale;
    updateTransform();
  };

  canvasArea.onmousedown = e => {
    if (e.target.closest('.drop-zone,.side-menu') || e.button !== 0) return;
    e.preventDefault();
    state.isPanning = true;
    state.startMouseX = e.clientX; state.startMouseY = e.clientY;
    state.startPanX = state.panX; state.startPanY = state.panY;
    canvasArea.classList.add('panning');
  };

  document.onmousemove = e => {
    if (!state.isPanning) return;
    state.panX = state.startPanX + (e.clientX - state.startMouseX);
    state.panY = state.startPanY + (e.clientY - state.startMouseY);
    updateTransform();
  };

  document.onmouseup = () => { state.isPanning = false; canvasArea.classList.remove('panning'); };
  canvasArea.oncontextmenu = e => { if (!e.target.closest('.side-menu')) e.preventDefault(); };

  // Touch
  let lastDist = 0;
  canvasArea.ontouchstart = e => {
    if (e.target.closest('.drop-zone,.side-menu')) return;
    if (e.touches.length === 1) {
      state.isPanning = true;
      state.startMouseX = e.touches[0].clientX; state.startMouseY = e.touches[0].clientY;
      state.startPanX = state.panX; state.startPanY = state.panY;
    } else if (e.touches.length === 2) {
      state.isPanning = false;
      lastDist = Math.hypot(e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY);
    }
  };
  canvasArea.ontouchmove = e => {
    if (e.target.closest('.drop-zone,.side-menu')) return;
    e.preventDefault();
    if (e.touches.length === 1 && state.isPanning) {
      state.panX = state.startPanX + (e.touches[0].clientX - state.startMouseX);
      state.panY = state.startPanY + (e.touches[0].clientY - state.startMouseY);
      updateTransform();
    } else if (e.touches.length === 2 && lastDist) {
      const dist = Math.hypot(e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY);
      const rect = canvasArea.getBoundingClientRect();
      const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
      const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
      const newScale = Math.max(0.1, Math.min(10, state.scale * (dist / lastDist)));
      const sc = newScale / state.scale;
      state.panX = cx - (cx - state.panX) * sc;
      state.panY = cy - (cy - state.panY) * sc;
      state.scale = newScale;
      updateTransform();
      lastDist = dist;
    }
  };
  canvasArea.ontouchend = () => { state.isPanning = false; lastDist = 0; };

  function updateTransform() {
    canvasInner.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
  }

  function fitToScreen() {
    if (!state.frames.length) return;
    const rect = canvasArea.getBoundingClientRect();
    const pad = 20;
    const total = state.frames.length + (state.showInfoCard ? 1 : 0);
    const rows = Math.ceil(total / state.gridCols);
    const frameAspect = state.videoWidth / state.videoHeight;
    const gap = state.spacing;
    
    const availW = rect.width - pad * 2;
    const availH = rect.height - pad * 2;
    
    const maxFW = (availW - (state.gridCols - 1) * gap) / state.gridCols;
    const maxFH = (availH - (rows - 1) * gap) / rows;
    
    let fw, fh;
    if (maxFW / frameAspect <= maxFH) { fw = maxFW; fh = fw / frameAspect; }
    else { fh = maxFH; fw = fh * frameAspect; }
    
    const gridW = state.gridCols * fw + (state.gridCols - 1) * gap;
    const gridH = rows * fh + (rows - 1) * gap;
    
    state.scale = 1;
    state.panX = (rect.width - gridW) / 2;
    state.panY = (rect.height - gridH) / 2;
    framesGrid.style.width = `${gridW}px`;
    updateTransform();
  }

  function fitToSingleFrame() {
    if (!state.frames.length) return;
    const rect = canvasArea.getBoundingClientRect();
    const pad = 40;
    const frameAspect = state.videoWidth / state.videoHeight;
    const gap = state.spacing;
    const gridW = framesGrid.offsetWidth || 600;
    const frameW = (gridW - (state.gridCols + 1) * gap) / state.gridCols;
    const frameH = frameW / frameAspect;
    const availW = rect.width - pad * 2;
    const availH = rect.height - pad * 2;
    const scaleX = availW / frameW;
    const scaleY = availH / frameH;
    const scale = Math.min(scaleX, scaleY, 3);
    const firstFrameCol = state.showInfoCard ? 1 : 0;
    const firstFrameX = gap + firstFrameCol * (frameW + gap);
    const firstFrameY = gap;
    state.scale = scale;
    state.panX = (rect.width / 2) - (firstFrameX + frameW / 2) * scale;
    state.panY = (rect.height / 2) - (firstFrameY + frameH / 2) * scale;
    updateTransform();
  }

  function setViewMode(mode) {
    state.viewMode = mode;
    qMode.textContent = mode === 'grid' ? 'GRID' : '1';
    qMode.classList.toggle('active', mode === 'single');
    const items = framesGrid.querySelectorAll('.frame-item');
    const offset = state.showInfoCard ? 1 : 0;
    items.forEach((item, i) => {
      if (i < offset) return;
      item.classList.toggle('dimmed', mode === 'single' && i > offset);
    });
    if (mode === 'single') fitToSingleFrame();
    else fitToScreen();
  }

  // CONTROLS
  gridColsInput.onchange = () => {
    state.gridCols = Math.max(1, Math.min(50, parseInt(gridColsInput.value) || 6));
    gridColsInput.value = state.gridCols;
    state.autoFit = false;
    toggleAutoFit.classList.remove('active');
    if (state.frames.length) { renderGrid(); updateGridHint(); fitToScreen(); }
  };

  canvasAspectSelect.onchange = () => {
    state.canvasAspect = canvasAspectSelect.value;
    // Turn on auto-fit when changing aspect
    state.autoFit = true;
    toggleAutoFit.classList.add('active');
    if (state.frames.length) {
      state.gridCols = calculateOptimalColumns(state.frames.length);
      gridColsInput.value = state.gridCols;
      renderGrid();
      updateGridHint();
      fitToScreen();
    } else {
      updateGridHint();
    }
  };

  selectionModeSelect.onchange = () => { state.selectionMode = selectionModeSelect.value; updateIntervalUI(); };
  frameCountInput.onchange = () => { state.frameCount = Math.max(1, Math.min(1000, parseInt(frameCountInput.value) || 24)); frameCountInput.value = state.frameCount; updateGridHint(); };
  
  // Frame count +/-
  countMinus.onclick = () => { if (state.frameCount > 1) { state.frameCount--; frameCountInput.value = state.frameCount; updateGridHint(); } };
  countPlus.onclick = () => { if (state.frameCount < 1000) { state.frameCount++; frameCountInput.value = state.frameCount; updateGridHint(); } };
  
  intervalValueInput.onchange = () => { state.intervalValue = Math.max(1, parseInt(intervalValueInput.value) || 1); intervalValueInput.value = state.intervalValue; };
  
  // Start/End frame inputs
  const frameStep = 10;
  startMinus.onclick = () => { state.startFrame = Math.max(0, state.startFrame - frameStep); startFrameInput.value = state.startFrame; };
  startPlus.onclick = () => { state.startFrame = Math.min(state.endFrame - 1, state.startFrame + frameStep); startFrameInput.value = state.startFrame; };
  endMinus.onclick = () => { state.endFrame = Math.max(state.startFrame + 1, state.endFrame - frameStep); endFrameInput.value = state.endFrame; };
  endPlus.onclick = () => { const maxFrame = Math.floor(state.videoDuration * state.videoFps); state.endFrame = Math.min(maxFrame, state.endFrame + frameStep); endFrameInput.value = state.endFrame; };
  startFrameInput.onchange = () => {
    const maxFrame = Math.floor(state.videoDuration * state.videoFps);
    state.startFrame = Math.max(0, Math.min(state.endFrame - 1, parseInt(startFrameInput.value) || 0));
    startFrameInput.value = state.startFrame;
  };
  endFrameInput.onchange = () => {
    const maxFrame = Math.floor(state.videoDuration * state.videoFps);
    state.endFrame = Math.max(state.startFrame + 1, Math.min(maxFrame, parseInt(endFrameInput.value) || maxFrame));
    endFrameInput.value = state.endFrame;
  };
  
  qualitySelect.onchange = () => { state.quality = parseFloat(qualitySelect.value); };

  function updateIntervalUI() {
    if (state.selectionMode === 'count') { countRow.style.display = 'flex'; intervalRow.style.display = 'none'; }
    else { countRow.style.display = 'none'; intervalRow.style.display = 'flex'; intervalLabel.textContent = state.selectionMode === 'seconds' ? 'Seconds' : 'Frames'; }
  }

  toggleMetadata.onclick = () => { state.showMetadata = !state.showMetadata; toggleMetadata.classList.toggle('active', state.showMetadata); metadataBar.classList.toggle('hidden', !state.showMetadata); };
  toggleTimecode.onclick = () => { state.showTimecode = !state.showTimecode; toggleTimecode.classList.toggle('active', state.showTimecode); document.querySelectorAll('.frame-timecode').forEach(el => el.classList.toggle('hidden', !state.showTimecode)); };
  toggleInfoCard.onclick = () => { state.showInfoCard = !state.showInfoCard; toggleInfoCard.classList.toggle('active', state.showInfoCard); if (state.frames.length) { renderGrid(); updateGridHint(); if (state.autoFit) fitToScreen(); } };
  toggleAutoFit.onclick = () => {
    state.autoFit = !state.autoFit;
    toggleAutoFit.classList.toggle('active', state.autoFit);
    if (state.autoFit && state.frames.length) {
      state.gridCols = calculateOptimalColumns(state.frames.length);
      gridColsInput.value = state.gridCols;
      renderGrid();
      updateGridHint();
      fitToScreen();
    }
  };

  fontSizeSlider.oninput = () => { state.fontSize = parseInt(fontSizeSlider.value); fontSizeValue.textContent = `${state.fontSize}px`; framesGrid.style.setProperty('--meta-font-size', `${state.fontSize}px`); };
  spacingSlider.oninput = () => { state.spacing = parseInt(spacingSlider.value); spacingValue.textContent = `${state.spacing}px`; framesGrid.style.setProperty('--grid-gap', `${state.spacing}px`); if (state.autoFit) fitToScreen(); };
  bgColorInput.oninput = () => { state.bgColor = bgColorInput.value; app.style.setProperty('--bg-color', state.bgColor); };

  // Timecode style controls
  tcTextColorInput.oninput = () => { state.tcTextColor = tcTextColorInput.value; updateTimecodeStyles(); };
  tcBgColorInput.oninput = () => { state.tcBgColor = tcBgColorInput.value; updateTimecodeStyles(); };
  tcOpacitySlider.oninput = () => { state.tcOpacity = parseInt(tcOpacitySlider.value) / 100; tcOpacityValue.textContent = `${tcOpacitySlider.value}%`; updateTimecodeStyles(); };
  tcAlignSelect.onchange = () => { state.tcAlign = tcAlignSelect.value; updateTimecodeStyles(); };
  tcPositionSelect.onchange = () => { state.tcPosition = tcPositionSelect.value; renderGrid(); if (state.autoFit) fitToScreen(); };

  generateBtn.onclick = generateFrames;

  
  // Column +/- buttons
  colsMinus.onclick = () => {
    if (state.gridCols > 1) {
      state.gridCols--;
      gridColsInput.value = state.gridCols;
      state.autoFit = false;
      toggleAutoFit.classList.remove('active');
      if (state.frames.length) { renderGrid(); updateGridHint(); fitToScreen(); }
    }
  };
  colsPlus.onclick = () => {
    if (state.gridCols < 50) {
      state.gridCols++;
      gridColsInput.value = state.gridCols;
      state.autoFit = false;
      toggleAutoFit.classList.remove('active');
      if (state.frames.length) { renderGrid(); updateGridHint(); fitToScreen(); }
    }
  };
  
  // Quick toolbar
  qMode.onclick = () => setViewMode(state.viewMode === 'grid' ? 'single' : 'grid');
  qPlay.onclick = () => { state.isPlaying ? stopAnimation() : startAnimation(); };
  qFit.onclick = () => { state.viewMode === 'single' ? fitToSingleFrame() : fitToScreen(); };
  qRegen.onclick = generateFrames;
  qExport.onclick = () => exportImage('jpeg', 2048);
  qMenu.onclick = toggleMenu;
  
  function updatePlayButton() {
    qPlay.textContent = state.isPlaying ? '■' : '▶';
    qPlay.classList.toggle('active', state.isPlaying);
  }
  exportSmallBtn.onclick = () => exportImage('jpeg', 2048);

  exportFullBtn.onclick = () => exportImage('png', 8192);
  // exportGifGridBtn.onclick = exportGifGrid; // GIF export disabled (CORS issues)
  // exportGifSingleBtn.onclick = exportGifSingle; // GIF export disabled (CORS issues)
  exportMp4GridBtn.onclick = () => exportMp4('grid');
  exportMp4SingleBtn.onclick = () => exportMp4('single');

  // Animation controls
  animFpsInput.onchange = () => { state.animFps = Math.max(1, Math.min(30, parseInt(animFpsInput.value) || 8)); animFpsInput.value = state.animFps; if (state.isPlaying) restartAnimation(); };
  fpsMinus.onclick = () => { if (state.animFps > 1) { state.animFps--; animFpsInput.value = state.animFps; if (state.isPlaying) restartAnimation(); } };
  fpsPlus.onclick = () => { if (state.animFps < 30) { state.animFps++; animFpsInput.value = state.animFps; if (state.isPlaying) restartAnimation(); } };
  animDirectionSelect.onchange = () => { state.animDirection = animDirectionSelect.value; if (state.isPlaying) restartAnimation(); };
  animPatternSelect.onchange = () => { state.animPattern = animPatternSelect.value; if (state.isPlaying) restartAnimation(); };
  
  function restartAnimation() {
    if (state.animInterval) {
      clearInterval(state.animInterval);
      state.animInterval = null;
    }
    // Restart with new settings
    state.animFrame = 0;
    const items = framesGrid.querySelectorAll('.frame-item');
    const offset = state.showInfoCard ? 1 : 0;
    const totalCells = items.length - offset;
    
    let sequence = [];
    const frameCount = state.frames.length;
    if (state.animDirection === 'forward') {
      for (let i = 0; i < frameCount; i++) sequence.push(i);
    } else if (state.animDirection === 'backward') {
      for (let i = frameCount - 1; i >= 0; i--) sequence.push(i);
    } else if (state.animDirection === 'pingpong') {
      for (let i = 0; i < frameCount; i++) sequence.push(i);
      for (let i = frameCount - 2; i > 0; i--) sequence.push(i);
    }
    const cellOrder = generateCellOrder(totalCells, state.gridCols);
    const interval = 1000 / state.animFps;
    let tick = 0;
    state.animInterval = setInterval(() => {
      tick++;
      const seqIndex = tick % sequence.length;
      items.forEach((item, i) => {
        if (i < offset) return;
        const cellIdx = i - offset;
        const cellOrderIdx = cellOrder.indexOf(cellIdx);
        const frameOffset = (cellOrderIdx + sequence[seqIndex]) % frameCount;
        const img = item.querySelector('img');
        const tc = item.querySelector('.frame-timecode');
        if (img && state.frames[frameOffset]) {
          img.src = state.frames[frameOffset].dataUrl;
          if (tc && state.showTimecode) {
            tc.textContent = `${formatTime(state.frames[frameOffset].time)} / F${state.frames[frameOffset].frameNumber}`;
          }
        }
      });
    }, interval);
  }

  playBtn.onclick = startAnimation;
  stopBtn.onclick = stopAnimation;

  function startAnimation() {
    if (!state.frames.length) return;
    state.isPlaying = true;
    state.animFrame = 0;
    playBtn.style.display = 'none';
    stopBtn.style.display = 'block';
    updatePlayButton();
    
    const items = framesGrid.querySelectorAll('.frame-item');
    const offset = state.showInfoCard ? 1 : 0;
    const totalCells = items.length - offset;
    
    // Generate animation sequence based on direction
    let sequence = [];
    const frameCount = state.frames.length;
    
    if (state.animDirection === 'forward') {
      for (let i = 0; i < frameCount; i++) sequence.push(i);
    } else if (state.animDirection === 'backward') {
      for (let i = frameCount - 1; i >= 0; i--) sequence.push(i);
    } else if (state.animDirection === 'pingpong') {
      for (let i = 0; i < frameCount; i++) sequence.push(i);
      for (let i = frameCount - 2; i > 0; i--) sequence.push(i);
    }
    
    // Generate cell order based on pattern
    const cellOrder = generateCellOrder(totalCells, state.gridCols);
    
    const interval = 1000 / state.animFps;
    let tick = 0;
    
    state.animInterval = setInterval(() => {
      tick++;
      const seqIndex = tick % sequence.length;
      
      items.forEach((item, i) => {
        if (i < offset) return;
        const cellIdx = i - offset;
        const cellOrderIdx = cellOrder.indexOf(cellIdx);
        const frameOffset = (cellOrderIdx + sequence[seqIndex]) % frameCount;
        const img = item.querySelector('img');
        const tc = item.querySelector('.frame-timecode');
        if (img && state.frames[frameOffset]) {
          img.src = state.frames[frameOffset].dataUrl;
          if (tc && state.showTimecode) {
            tc.textContent = `${formatTime(state.frames[frameOffset].time)} / F${state.frames[frameOffset].frameNumber}`;
          }
        }
      });
    }, interval);
  }

  function generateCellOrder(totalCells, cols) {
    const rows = Math.ceil(totalCells / cols);
    const order = [];
    
    if (state.animPattern === 'sequential') {
      for (let i = 0; i < totalCells; i++) order.push(i);
    } else if (state.animPattern === 'center') {
      // Center-out: spiral from center
      const centerX = (cols - 1) / 2;
      const centerY = (rows - 1) / 2;
      const cells = [];
      for (let i = 0; i < totalCells; i++) {
        const x = i % cols;
        const y = Math.floor(i / cols);
        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
        cells.push({ idx: i, dist });
      }
      cells.sort((a, b) => a.dist - b.dist);
      cells.forEach(c => order.push(c.idx));
    } else if (state.animPattern === 'snake') {
      // Snake: zigzag rows
      for (let r = 0; r < rows; r++) {
        if (r % 2 === 0) {
          for (let c = 0; c < cols; c++) {
            const idx = r * cols + c;
            if (idx < totalCells) order.push(idx);
          }
        } else {
          for (let c = cols - 1; c >= 0; c--) {
            const idx = r * cols + c;
            if (idx < totalCells) order.push(idx);
          }
        }
      }
    } else if (state.animPattern === 'vertical') {
      // Column by column
      for (let c = 0; c < cols; c++) {
        for (let r = 0; r < rows; r++) {
          const idx = r * cols + c;
          if (idx < totalCells) order.push(idx);
        }
      }
    }
    
    return order;
  }

  function stopAnimation() {
    state.isPlaying = false;
    if (state.animInterval) {
      clearInterval(state.animInterval);
      state.animInterval = null;
    }
    playBtn.style.display = 'block';
    stopBtn.style.display = 'none';
    updatePlayButton();
    
    // Restore original frames WITHOUT changing zoom/pan
    renderGrid();
  }

  // GIF Grid Export - animated grid like JPEG but with looping frames
  async function exportGifGrid() {
    if (!state.frames.length) return;
    
    loadingOverlay.classList.add('visible');
    loadingProgress.textContent = 'Loading GIF library...';
    
    if (!window.GIF) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js');
    }

    const total = state.frames.length + (state.showInfoCard ? 1 : 0);
    const rows = Math.ceil(total / state.gridCols);
    const frameAspect = state.videoWidth / state.videoHeight;
    const gap = state.spacing;
    const headerH = state.showMetadata ? 72 : 0;

    let baseFrameW = 300;
    let baseFrameH = Math.round(baseFrameW / frameAspect);
    let gridW = state.gridCols * baseFrameW + (state.gridCols - 1) * gap;
    let gridH = rows * baseFrameH + (rows - 1) * gap;
    let totalW = gridW;
    let totalH = headerH + gridH;

    const maxSize = 2048;
    const maxDim = Math.max(totalW, totalH);
    let exportScale = maxDim > maxSize ? maxSize / maxDim : 1;
    
    const frameW = Math.round(baseFrameW * exportScale);
    const frameH = Math.round(baseFrameH * exportScale);
    gridW = state.gridCols * frameW + (state.gridCols - 1) * gap;
    gridH = rows * frameH + (rows - 1) * gap;
    totalW = gridW;
    totalH = headerH + gridH;

    const screenGridWidth = framesGrid.offsetWidth || 600;
    const screenFrameW = (screenGridWidth - (state.gridCols - 1) * gap) / state.gridCols;
    const fontScale = frameW / screenFrameW;
    const tcFontSize = Math.round(state.fontSize * fontScale);
    const headerFontSize = Math.round(11 * fontScale);

    const r = parseInt(state.tcBgColor.slice(1,3), 16);
    const g = parseInt(state.tcBgColor.slice(3,5), 16);
    const b = parseInt(state.tcBgColor.slice(5,7), 16);

    const delay = Math.round(1000 / state.animFps);
    
    const gif = new GIF({
      workers: 2, quality: 10, width: totalW, height: totalH,
      workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
    });

    loadingProgress.textContent = 'Loading frame images...';
    const frameImages = await Promise.all(state.frames.map(f => {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = f.dataUrl;
      });
    }));

    const canvas = document.createElement('canvas');
    canvas.width = totalW;
    canvas.height = totalH;
    const ctx = canvas.getContext('2d');

    for (let tick = 0; tick < state.frames.length; tick++) {
      loadingProgress.textContent = `Rendering frame ${tick + 1}/${state.frames.length}`;
      
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, totalW, totalH);

      if (state.showMetadata) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, totalW, headerH);
        ctx.fillStyle = '#35f2a3';
        ctx.fillRect(10, (headerH - 6) / 2, 6, 6);
        ctx.fillStyle = '#fff';
        ctx.font = `700 ${headerFontSize}px system-ui`;
        ctx.fillText('FRAMEGRID v0.08', 22, headerH * 0.65);
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = `${headerFontSize}px system-ui`;
        const logoWidth = ctx.measureText('FRAMEGRID v0.08').width;
        const dateStr = state.videoDate ? ` · ${formatDate(state.videoDate)}` : '';
        const info = `${state.videoFile?.name || 'video'} · ${state.videoWidth}×${state.videoHeight} · ${formatTime(state.videoDuration)} · ${state.frames.length}f${dateStr}`;
        ctx.fillText(info, 22 + logoWidth + 16, headerH * 0.65);
      }

      let cellIndex = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < state.gridCols; col++) {
          const x = col * (frameW + gap);
          const y = headerH + row * (frameH + gap);
          
          if (state.showInfoCard && cellIndex === 0) {
            ctx.fillStyle = '#000';
            ctx.fillRect(x, y, frameW, frameH);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.strokeRect(x, y, frameW, frameH);
            ctx.fillStyle = '#35f2a3';
            ctx.font = `bold ${tcFontSize * 1.2}px system-ui`;
            ctx.fillText('VIDEO INFO', x + 10, y + tcFontSize * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = `${tcFontSize}px system-ui`;
            [`File: ${state.videoFile?.name}`, `Res: ${state.videoWidth}×${state.videoHeight}`, `Dur: ${formatTime(state.videoDuration)}`, `Frames: ${state.frames.length}`]
              .forEach((line, li) => ctx.fillText(line, x + 10, y + tcFontSize * 3.5 + li * tcFontSize * 1.5));
            cellIndex++;
            continue;
          }

          const frameIdx = state.showInfoCard ? cellIndex - 1 : cellIndex;
          if (frameIdx >= state.frames.length) { cellIndex++; continue; }

          const animFrameIdx = (frameIdx + tick) % state.frames.length;
          const frame = state.frames[animFrameIdx];
          const img = frameImages[animFrameIdx];

          ctx.drawImage(img, x, y, frameW, frameH);

          if (state.showTimecode) {
            const padding = Math.round(4 * fontScale);
            const tcH = tcFontSize + padding * 2;
            const tcY = state.tcPosition === 'top' ? y : y + frameH - tcH;
            ctx.fillStyle = `rgba(${r},${g},${b},${state.tcOpacity})`;
            ctx.fillRect(x, tcY, frameW, tcH);
            ctx.fillStyle = state.tcTextColor;
            ctx.font = `${tcFontSize}px system-ui`;
            ctx.textAlign = state.tcAlign;
            const textX = state.tcAlign === 'left' ? x + padding : state.tcAlign === 'right' ? x + frameW - padding : x + frameW / 2;
            ctx.fillText(`${formatTime(frame.time)} / F${frame.frameNumber}`, textX, tcY + tcFontSize + padding - 2);
            ctx.textAlign = 'left';
          }
          cellIndex++;
        }
      }
      gif.addFrame(ctx, { copy: true, delay });
    }

    loadingProgress.textContent = 'Encoding GIF...';
    gif.on('finished', blob => {
      loadingOverlay.classList.remove('visible');
      const link = document.createElement('a');
      const name = (state.videoFile?.name || 'export').replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 20);
      const now = new Date();
      const date = `${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}${String(now.getFullYear()).slice(-2)}`;
      link.download = `fg_${name}_grid_${state.frames.length}f_${state.animFps}fps_c${state.gridCols}_${date}.gif`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    });
    gif.render();
  }

  // GIF Single Export - one frame at a time with metadata header
  async function exportGifSingle() {
    if (!state.frames.length) return;
    
    loadingOverlay.classList.add('visible');
    loadingProgress.textContent = 'Loading GIF library...';
    
    if (!window.GIF) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js');
    }
    
    const frameAspect = state.videoWidth / state.videoHeight;
    const maxSize = 2048;
    let gifWidth = Math.min(maxSize, state.videoWidth);
    let gifHeight = Math.round(gifWidth / frameAspect);
    const headerH = state.showMetadata ? 48 : 0;
    const totalHeight = gifHeight + headerH;
    
    if (totalHeight > maxSize) {
      const scale = maxSize / totalHeight;
      gifWidth = Math.round(gifWidth * scale);
      gifHeight = Math.round(gifHeight * scale);
    }
    
    const headerFontSize = Math.max(Math.round(headerH * 0.35), 12);
    const tcFontSize = Math.max(Math.round(gifWidth * 0.025), 14);
    const delay = Math.round(1000 / state.animFps);
    
    const r = parseInt(state.tcBgColor.slice(1,3), 16);
    const g = parseInt(state.tcBgColor.slice(3,5), 16);
    const b = parseInt(state.tcBgColor.slice(5,7), 16);
    
    const gif = new GIF({
      workers: 2, quality: 10, width: gifWidth, height: gifHeight + headerH,
      workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
    });
    
    const canvas = document.createElement('canvas');
    canvas.width = gifWidth;
    canvas.height = gifHeight + headerH;
    const ctx = canvas.getContext('2d');
    
    for (let i = 0; i < state.frames.length; i++) {
      loadingProgress.textContent = `Adding frame ${i + 1}/${state.frames.length}`;
      const frame = state.frames[i];
      
      await new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
          ctx.fillStyle = state.bgColor;
          ctx.fillRect(0, 0, gifWidth, gifHeight + headerH);
          
          if (state.showMetadata) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, gifWidth, headerH);
            ctx.fillStyle = '#35f2a3';
            ctx.fillRect(10, (headerH - 6) / 2, 6, 6);
            ctx.fillStyle = '#fff';
            ctx.font = `700 ${headerFontSize}px system-ui`;
            ctx.fillText('FRAMEGRID v0.08', 22, headerH * 0.65);
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = `${headerFontSize}px system-ui`;
            const logoWidth = ctx.measureText('FRAMEGRID v0.08').width;
            const info = `${state.videoFile?.name || 'video'} · ${state.videoWidth}×${state.videoHeight} · Frame ${i + 1}/${state.frames.length}`;
            ctx.fillText(info, 22 + logoWidth + 16, headerH * 0.65);
          }
          
          ctx.drawImage(img, 0, headerH, gifWidth, gifHeight);
          
          if (state.showTimecode) {
            const tcH = tcFontSize * 2;
            const tcY = state.tcPosition === 'top' ? headerH : headerH + gifHeight - tcH;
            ctx.fillStyle = `rgba(${r},${g},${b},${state.tcOpacity})`;
            ctx.fillRect(0, tcY, gifWidth, tcH);
            ctx.fillStyle = state.tcTextColor;
            ctx.font = `${tcFontSize}px system-ui`;
            ctx.textAlign = state.tcAlign;
            const textX = state.tcAlign === 'left' ? 8 : state.tcAlign === 'right' ? gifWidth - 8 : gifWidth / 2;
            ctx.fillText(`${formatTime(frame.time)} / F${frame.frameNumber}`, textX, tcY + tcFontSize + 4);
            ctx.textAlign = 'left';
          }
          
          gif.addFrame(ctx, { copy: true, delay });
          resolve();
        };
        img.src = frame.dataUrl;
      });
    }
    
    loadingProgress.textContent = 'Encoding GIF...';
    gif.on('finished', blob => {
      loadingOverlay.classList.remove('visible');
      const link = document.createElement('a');
      const name = (state.videoFile?.name || 'export').replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 20);
      const now = new Date();
      const date = `${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}${String(now.getFullYear()).slice(-2)}`;
      link.download = `fg_${name}_single_${state.frames.length}f_${state.animFps}fps_${date}.gif`;
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    });
    gif.render();
  }

  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // MP4 Export using mp4-muxer for true MP4 (H.264)
  async function exportMp4(mode) {
    if (!state.frames.length) return;
    
    loadingOverlay.classList.add('visible');
    loadingProgress.textContent = 'Loading MP4 encoder...';
    
    // Load mp4-muxer library
    if (!window.Mp4Muxer) {
      await loadScript('https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/build/mp4-muxer.min.js');
    }
    
    const frameAspect = state.videoWidth / state.videoHeight;
    const total = state.frames.length + (state.showInfoCard ? 1 : 0);
    const rows = Math.ceil(total / state.gridCols);
    const gap = state.spacing;
    
    let canvasW, canvasH;
    
    if (mode === 'grid') {
      let baseFrameW = 120; // Reduced for faster encoding
      let baseFrameH = Math.round(baseFrameW / frameAspect);
      let gridW = state.gridCols * baseFrameW + (state.gridCols - 1) * gap;
      let gridH = rows * baseFrameH + (rows - 1) * gap;
      const headerH = state.showMetadata ? 56 : 0;
      canvasW = gridW;
      canvasH = headerH + gridH;
      const maxSize = 1080; // Optimized for web
      if (Math.max(canvasW, canvasH) > maxSize) {
        const scale = maxSize / Math.max(canvasW, canvasH);
        canvasW = Math.round(canvasW * scale);
        canvasH = Math.round(canvasH * scale);
      }
    } else {
      canvasW = Math.min(720, state.videoWidth); // Optimized resolution
      canvasH = Math.round(canvasW / frameAspect) + (state.showMetadata ? 48 : 0);
    }
    
    // Dimensions must be even for H.264
    canvasW = Math.floor(canvasW / 2) * 2;
    canvasH = Math.floor(canvasH / 2) * 2;
    
    const canvas = document.createElement('canvas');
    canvas.width = canvasW;
    canvas.height = canvasH;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    loadingProgress.textContent = 'Loading frames...';
    const frameImages = await Promise.all(state.frames.map(f => {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = f.dataUrl;
      });
    }));
    
    // Generate animation sequence
    let sequence = [];
    const frameCount = state.frames.length;
    if (state.animDirection === 'forward') {
      for (let i = 0; i < frameCount; i++) sequence.push(i);
    } else if (state.animDirection === 'backward') {
      for (let i = frameCount - 1; i >= 0; i--) sequence.push(i);
    } else {
      for (let i = 0; i < frameCount; i++) sequence.push(i);
      for (let i = frameCount - 2; i > 0; i--) sequence.push(i);
    }
    
    const cellOrder = generateCellOrder(state.frames.length, state.gridCols);
    const r = parseInt(state.tcBgColor.slice(1,3), 16);
    const g = parseInt(state.tcBgColor.slice(3,5), 16);
    const b = parseInt(state.tcBgColor.slice(5,7), 16);
    
    // Check for VideoEncoder support
    if (typeof VideoEncoder === 'undefined') {
      loadingOverlay.classList.remove('visible');
      alert('MP4 export requires a modern browser with VideoEncoder support.\n\nTry Chrome 94+, Edge 94+, or Safari 16.4+.\n\nAlternatively, use GIF export.');
      return;
    }
    
    loadingProgress.textContent = 'Initializing encoder...';
    
    // Setup mp4-muxer
    const muxer = new Mp4Muxer.Muxer({
      target: new Mp4Muxer.ArrayBufferTarget(),
      video: {
        codec: 'avc',
        width: canvasW,
        height: canvasH
      },
      fastStart: 'in-memory'
    });
    
    // Setup VideoEncoder
    const frameDuration = 1000000 / state.animFps; // microseconds
    let encodedFrames = 0;
    
    const encoder = new VideoEncoder({
      output: (chunk, meta) => {
        muxer.addVideoChunk(chunk, meta);
      },
      error: (e) => {
        console.error('Encoder error:', e);
        loadingOverlay.classList.remove('visible');
        alert('Encoding error: ' + e.message);
      }
    });
    
    await encoder.configure({
      codec: 'avc1.640028', // H.264 High Level 4.0 - supports up to 2,073,600 pixels
      width: canvasW,
      height: canvasH,
      bitrate: 4000000,
      framerate: state.animFps
    });
    
    // Render and encode frames
    for (let tick = 0; tick < sequence.length; tick++) {
      loadingProgress.textContent = `Encoding ${tick + 1}/${sequence.length}`;
      
      // Render frame to canvas
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, canvasW, canvasH);
      
      if (mode === 'grid') {
        renderMp4GridFrame(ctx, canvasW, canvasH, frameImages, tick, sequence, cellOrder, rows, frameAspect, r, g, b);
      } else {
        renderMp4SingleFrame(ctx, canvasW, canvasH, frameImages, sequence[tick], r, g, b);
      }
      
      // Create VideoFrame and encode
      const videoFrame = new VideoFrame(canvas, {
        timestamp: tick * frameDuration,
        duration: frameDuration
      });
      
      const keyFrame = tick % 30 === 0; // Keyframe every 30 frames
      encoder.encode(videoFrame, { keyFrame });
      videoFrame.close();
      
      // Small delay to prevent UI freeze
      if (tick % 5 === 0) {
        await new Promise(r => setTimeout(r, 0));
      }
    }
    
    loadingProgress.textContent = 'Finalizing MP4...';
    
    await encoder.flush();
    muxer.finalize();
    
    const mp4Data = muxer.target.buffer;
    const blob = new Blob([mp4Data], { type: 'video/mp4' });
    
    loadingOverlay.classList.remove('visible');
    
    const link = document.createElement('a');
    const name = (state.videoFile?.name || 'export').replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 20);
    const now = new Date();
    const date = `${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}${String(now.getFullYear()).slice(-2)}`;
    link.download = `fg_${name}_${mode}_${state.frames.length}f_${state.animFps}fps_${date}.mp4`;
    link.href = URL.createObjectURL(blob);
    link.click();
    URL.revokeObjectURL(link.href);
  }
  
  function renderMp4GridFrame(ctx, w, h, frameImages, tick, sequence, cellOrder, rows, frameAspect, r, g, b) {
    const headerH = state.showMetadata ? Math.round(h * 0.04) : 0;
    const gridH = h - headerH;
    const gap = state.spacing;
    const frameH = (gridH - (rows - 1) * gap) / rows;
    const frameW = frameH * frameAspect;
    const gridW = state.gridCols * frameW + (state.gridCols - 1) * gap;
    const offsetX = (w - gridW) / 2;
    const fontScale = frameW / 150;
    const tcFontSize = Math.max(Math.round(state.fontSize * fontScale), 8);
    const frameCount = state.frames.length;
    
    if (state.showMetadata && headerH > 0) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, headerH);
      ctx.fillStyle = '#35f2a3';
      ctx.fillRect(8, headerH / 2 - 3, 5, 5);
      ctx.fillStyle = '#fff';
      ctx.font = `700 ${Math.round(headerH * 0.5)}px system-ui`;
      ctx.fillText('FRAMEGRID v0.10', 18, headerH * 0.7);
    }
    
    let cellIdx = 0;
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < state.gridCols; col++) {
        if (cellIdx >= frameCount) break;
        const x = offsetX + col * (frameW + gap);
        const y = headerH + row * (frameH + gap);
        
        const cellOrderIdx = cellOrder.indexOf(cellIdx);
        const animFrameIdx = (cellOrderIdx + sequence[tick % sequence.length]) % frameCount;
        const frame = state.frames[animFrameIdx];
        const img = frameImages[animFrameIdx];
        
        ctx.drawImage(img, x, y, frameW, frameH);
        
        if (state.showTimecode) {
          const tcH = tcFontSize + 6;
          const tcY = state.tcPosition === 'top' ? y : y + frameH - tcH;
          ctx.fillStyle = `rgba(${r},${g},${b},${state.tcOpacity})`;
          ctx.fillRect(x, tcY, frameW, tcH);
          ctx.fillStyle = state.tcTextColor;
          ctx.font = `${tcFontSize}px system-ui`;
          ctx.fillText(`${formatTime(frame.time)}`, x + 3, tcY + tcFontSize);
        }
        cellIdx++;
      }
    }
  }
  
  function renderMp4SingleFrame(ctx, w, h, frameImages, frameIdx, r, g, b) {
    const headerH = state.showMetadata ? 40 : 0;
    const frameH = h - headerH;
    const frame = state.frames[frameIdx];
    const img = frameImages[frameIdx];
    const tcFontSize = Math.round(w * 0.025);
    const frameCount = state.frames.length;
    
    if (state.showMetadata) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, headerH);
      ctx.fillStyle = '#35f2a3';
      ctx.fillRect(8, headerH / 2 - 3, 5, 5);
      ctx.fillStyle = '#fff';
      ctx.font = `700 ${Math.round(headerH * 0.4)}px system-ui`;
      ctx.fillText(`FRAMEGRID v0.10 · Frame ${frameIdx + 1}/${frameCount}`, 18, headerH * 0.65);
    }
    
    ctx.drawImage(img, 0, headerH, w, frameH);
    
    if (state.showTimecode) {
      const tcH = tcFontSize * 2;
      const tcY = state.tcPosition === 'top' ? headerH : h - tcH;
      ctx.fillStyle = `rgba(${r},${g},${b},${state.tcOpacity})`;
      ctx.fillRect(0, tcY, w, tcH);
      ctx.fillStyle = state.tcTextColor;
      ctx.font = `${tcFontSize}px system-ui`;
      ctx.fillText(`${formatTime(frame.time)} / F${frame.frameNumber}`, 8, tcY + tcFontSize + 2);
    }
  }

  // EXPORT
  function exportImage(format, maxSize) {
    if (!state.frames.length) return;

    const total = state.frames.length + (state.showInfoCard ? 1 : 0);
    const rows = Math.ceil(total / state.gridCols);
    const frameAspect = state.videoWidth / state.videoHeight;
    const gap = state.spacing;
    const headerH = state.showMetadata ? 72 : 0; // 72px = 2x of 36px UI header

    // Calculate current screen frame size for reference
    const screenGridWidth = framesGrid.offsetWidth || 600;
    const screenFrameW = (screenGridWidth - (state.gridCols - 1) * gap) / state.gridCols;

    // Base export frame size
    let baseFrameW = 300;
    let baseFrameH = Math.round(baseFrameW / frameAspect);
    
    let gridW = state.gridCols * baseFrameW + (state.gridCols - 1) * gap;
    let gridH = rows * baseFrameH + (rows - 1) * gap;
    let totalW = gridW;
    let totalH = headerH + gridH;

    // Scale to fit maxSize
    const maxDim = Math.max(totalW, totalH);
    let exportScale = maxDim > maxSize ? maxSize / maxDim : 1;
    
    const frameW = Math.round(baseFrameW * exportScale);
    const frameH = Math.round(baseFrameH * exportScale);
    gridW = state.gridCols * frameW + (state.gridCols - 1) * gap;
    gridH = rows * frameH + (rows - 1) * gap;
    totalW = gridW;
    totalH = headerH + gridH;

    // KEY: Font size scales proportionally from screen to export
    // If screen frame is 100px and export frame is 300px, scale = 3x
    const fontScale = frameW / screenFrameW;
    const tcFontSize = Math.round(state.fontSize * fontScale);
    const headerFontSize = Math.round(11 * fontScale); // 11px is the UI header font

    const canvas = document.createElement('canvas');
    canvas.width = totalW;
    canvas.height = totalH;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = state.bgColor;
    ctx.fillRect(0, 0, totalW, totalH);

    // Header
    if (state.showMetadata) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, totalW, headerH);
      
      // Left side: green dot + FRAMEGRID + info
      ctx.fillStyle = '#35f2a3';
      ctx.fillRect(10, (headerH - 6) / 2, 6, 6);
      
      ctx.fillStyle = '#fff';
      ctx.font = `700 ${headerFontSize}px system-ui`;
      ctx.fillText('FRAMEGRID v0.08', 22, headerH * 0.65);
      
      // Info text after logo
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.font = `${headerFontSize}px system-ui`;
      const logoWidth = ctx.measureText('FRAMEGRID v0.08').width;
      const dateStr = state.videoDate ? ` · ${formatDate(state.videoDate)}` : '';
      const info = `${state.videoFile?.name || 'video'} · ${state.videoWidth}×${state.videoHeight} · ${formatTime(state.videoDuration)} · ${state.frames.length}f${dateStr}`;
      ctx.fillText(info, 22 + logoWidth + 16, headerH * 0.65);
    }

    const items = [];
    if (state.showInfoCard) items.push({ type: 'info' });
    state.frames.forEach(f => items.push({ type: 'frame', data: f }));

    // Parse BG color
    const r = parseInt(state.tcBgColor.slice(1,3), 16);
    const g = parseInt(state.tcBgColor.slice(3,5), 16);
    const b = parseInt(state.tcBgColor.slice(5,7), 16);

    const promises = items.map((item, i) => new Promise(resolve => {
      const col = i % state.gridCols;
      const row = Math.floor(i / state.gridCols);
      const x = col * (frameW + gap);
      const y = headerH + row * (frameH + gap);

      if (item.type === 'info') {
        ctx.fillStyle = '#000';
        ctx.fillRect(x, y, frameW, frameH);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.strokeRect(x, y, frameW, frameH);
        ctx.fillStyle = '#35f2a3';
        ctx.font = `bold ${tcFontSize * 1.2}px system-ui`;
        ctx.fillText('VIDEO INFO', x + 10, y + tcFontSize * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = `${tcFontSize}px system-ui`;
        [`File: ${state.videoFile?.name}`, `Res: ${state.videoWidth}×${state.videoHeight}`, `Dur: ${formatTime(state.videoDuration)}`, `Frames: ${state.frames.length}`]
          .forEach((line, li) => ctx.fillText(line, x + 10, y + tcFontSize * 3.5 + li * tcFontSize * 1.5));
        resolve();
      } else {
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, x, y, frameW, frameH);
          if (state.showTimecode) {
            const padding = Math.round(4 * fontScale);
            const tcH = tcFontSize + padding * 2;
            const tcY = state.tcPosition === 'top' ? y : y + frameH - tcH;
            
            ctx.fillStyle = `rgba(${r},${g},${b},${state.tcOpacity})`;
            ctx.fillRect(x, tcY, frameW, tcH);
            
            ctx.fillStyle = state.tcTextColor;
            ctx.font = `${tcFontSize}px system-ui`;
            ctx.textAlign = state.tcAlign;
            const textX = state.tcAlign === 'left' ? x + padding : state.tcAlign === 'right' ? x + frameW - padding : x + frameW / 2;
            ctx.fillText(`${formatTime(item.data.time)} / F${item.data.frameNumber}`, textX, tcY + tcFontSize + padding - 2);
            ctx.textAlign = 'left';
          }
          resolve();
        };
        img.src = item.data.dataUrl;
      }
    }));

    Promise.all(promises).then(() => {
      const link = document.createElement('a');
      const ext = format === 'jpeg' ? 'jpg' : 'png';
      
      const name = (state.videoFile?.name || 'export').replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 20);
      const asp = state.canvasAspect !== 'auto' ? state.canvasAspect.replace(':', 'x') : 'auto';
      const mode = state.selectionMode === 'count' ? `${state.frameCount}f` : state.selectionMode === 'seconds' ? `e${state.intervalValue}s` : `e${state.intervalValue}f`;
      const now = new Date();
      const date = `${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}${String(now.getFullYear()).slice(-2)}`;
      const time = `${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
      const size = maxSize <= 2048 ? '2k' : maxSize <= 4096 ? '4k' : 'full';
      
      link.download = `fg_${name}_${asp}_${state.frames.length}f_${mode}_c${state.gridCols}_${date}_${time}_${size}.${ext}`;
      link.href = canvas.toDataURL(`image/${format}`, format === 'jpeg' ? 0.92 : 1);
      link.click();
    });
  }

  // UTILS
  function formatTime(s) { return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(Math.floor(s%60)).padStart(2,'0')}`; }
  function formatDate(d) { return `${String(d.getDate()).padStart(2,'0')}.${String(d.getMonth()+1).padStart(2,'0')}.${d.getFullYear()}`; }

  // INIT
  updateIntervalUI();
  app.style.setProperty('--bg-color', state.bgColor);
  fontSizeValue.textContent = `${state.fontSize}px`;
  spacingValue.textContent = `${state.spacing}px`;
  framesGrid.style.setProperty('--meta-font-size', `${state.fontSize}px`);

  document.onkeydown = e => {
    if (e.target.matches('input,select')) return;
    if (e.key === 'Escape') { closeMenu(); if (state.isPlaying) stopAnimation(); }
    if (e.key === 'f' || e.key === 'F') { state.viewMode === 'single' ? fitToSingleFrame() : fitToScreen(); }
    if (e.key === 'm' || e.key === 'M') toggleMenu();
    if (e.key === ' ') { e.preventDefault(); state.isPlaying ? stopAnimation() : startAnimation(); }
    if (e.key === 'g' || e.key === 'G') setViewMode('grid');
    if (e.key === '1') setViewMode('single');
  };

  // Window resize - recalculate auto-fit
  let resizeTimeout;
  window.onresize = () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      if (state.autoFit && state.frames.length) {
        if (state.canvasAspect === 'auto') {
          state.gridCols = calculateOptimalColumns(state.frames.length);
          gridColsInput.value = state.gridCols;
          renderGrid();
          updateGridHint();
        }
        fitToScreen();
      }
    }, 150);
  };

})();
  </script>
</body>
</html>
